"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const _1 = require(".");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
/**
 * The size of an empty zip file is 22 bytes
 *
 * Ref: https://en.wikipedia.org/wiki/ZIP_(file_format)
 */
const EMPTY_ZIP_FILE_SIZE = 22;
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async build() { }
    async isPublished() {
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        try {
            const s3 = await this.host.aws.s3Client({
                ...(0, _1.destinationToClientOptions)(destination),
                quiet: true,
            });
            this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
            if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
                this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
                return true;
            }
        }
        catch (e) {
            this.host.emitMessage(progress_1.EventType.DEBUG, `${e.message}`);
        }
        return false;
    }
    async publish() {
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const clientOptions = (0, _1.destinationToClientOptions)(destination);
        const s3 = await this.host.aws.s3Client(clientOptions);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => (await this.host.aws.discoverTargetAccount(clientOptions))?.accountId;
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2.type) {
            case 'no_encryption':
                break;
            case 'aes256':
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case 'kms':
                // We must include the key ID otherwise S3 will encrypt with the default key
                paramsEncryption = {
                    ServerSideEncryption: 'aws:kms',
                    SSEKMSKeyId: encryption2.kmsKeyId,
                };
                break;
            case 'does_not_exist':
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case 'access_denied':
                this.host.emitMessage(progress_1.EventType.DEBUG, `Could not read encryption settings of bucket '${destination.bucketName}': uploading with default settings ("cdk bootstrap" to version 9 if your organization's policies prevent a successful upload or to get rid of this message).`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable
            ? await this.externalPackageFile(this.asset.source.executable)
            : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: (0, fs_1.createReadStream)(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }, paramsEncryption);
        await s3.upload(params).promise();
    }
    async packageFile(source) {
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await (0, fs_extra_1.pathExists)(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${packagedPath}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${packagedPath}`);
            await (0, archive_1.zipDirectory)(fullPath, packagedPath, (m) => this.host.emitMessage(progress_1.EventType.DEBUG, m));
            return { packagedPath, contentType };
        }
        else {
            const contentType = mime.getType(fullPath) ?? 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await (0, shell_1.shell)(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     *
     * If the file is too small, we discount it as a cache hit. There is an issue
     * somewhere that sometimes produces empty zip files, and we would otherwise
     * never retry building those assets without users having to manually clear
     * their bucket, which is a bad experience.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return (response.Contents != null &&
        response.Contents.some((object) => object.Key === key && (object.Size == null || object.Size > EMPTY_ZIP_FILE_SIZE)));
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    async bucketOwnership(s3, bucket) {
        return cached(this.ownerships, bucket, () => this._bucketOwnership(s3, bucket));
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket) {
        try {
            await s3.getBucketLocation({ Bucket: bucket }).promise();
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket }).promise();
            const l = encryption?.ServerSideEncryptionConfiguration?.Rules?.length ?? 0;
            if (l > 0) {
                const apply = encryption?.ServerSideEncryptionConfiguration?.Rules[0]
                    ?.ApplyServerSideEncryptionByDefault;
                let ssealgo = apply?.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return { type: 'aes256' };
                if (ssealgo === 'aws:kms')
                    return { type: 'kms', kmsKeyId: apply?.KMSMasterKeyID };
            }
            return { type: 'no_encryption' };
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return { type: 'does_not_exist' };
            }
            if (e.code === 'ServerSideEncryptionConfigurationNotFoundError') {
                return { type: 'no_encryption' };
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return { type: 'access_denied' };
            }
            return { type: 'no_encryption' };
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUNoRiw2QkFBNkI7QUFDN0Isd0JBQStDO0FBRS9DLDZDQUEyQztBQUMzQyx3Q0FBMEM7QUFFMUMsMENBQXlDO0FBQ3pDLGtEQUF5RDtBQUN6RCxvQ0FBaUM7QUFFakM7Ozs7R0FJRztBQUNILE1BQU0sbUJBQW1CLEdBQUcsRUFBRSxDQUFDO0FBRS9CLE1BQWEsZ0JBQWdCO0lBRzNCLFlBQ21CLE9BQWUsRUFDZixLQUF3QixFQUN4QixJQUFrQjtRQUZsQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ2YsVUFBSyxHQUFMLEtBQUssQ0FBbUI7UUFDeEIsU0FBSSxHQUFKLElBQUksQ0FBYztRQUVuQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSyxLQUFtQixDQUFDO0lBRS9CLEtBQUssQ0FBQyxXQUFXO1FBQ3RCLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBQSxxQ0FBc0IsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hGLE1BQU0sS0FBSyxHQUFHLFFBQVEsV0FBVyxDQUFDLFVBQVUsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEUsSUFBSSxDQUFDO1lBQ0gsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7Z0JBQ3RDLEdBQUcsSUFBQSw2QkFBMEIsRUFBQyxXQUFXLENBQUM7Z0JBQzFDLEtBQUssRUFBRSxJQUFJO2FBQ1osQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLElBQUksQ0FB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O1FBQ25DLENBQUM7SUFDSCxDQUFDOztBQXhEdUIsd0JBQU0sR0FBRyxJQUFJLE9BQU8sRUFBbUMsQUFBakQsQ0FBa0Q7QUEyRGxGLEtBQUssVUFBVSxNQUFNLENBQU8sS0FBZ0IsRUFBRSxHQUFNLEVBQUUsT0FBNkI7SUFDakYsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDbkIsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0QixPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcsIEZpbGVTb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCB7IGRlc3RpbmF0aW9uVG9DbGllbnRPcHRpb25zIH0gZnJvbSAnLic7XG5pbXBvcnQgeyBGaWxlTWFuaWZlc3RFbnRyeSB9IGZyb20gJy4uLy4uL2Fzc2V0LW1hbmlmZXN0JztcbmltcG9ydCB7IEV2ZW50VHlwZSB9IGZyb20gJy4uLy4uL3Byb2dyZXNzJztcbmltcG9ydCB7IHppcERpcmVjdG9yeSB9IGZyb20gJy4uL2FyY2hpdmUnO1xuaW1wb3J0IHsgSUFzc2V0SGFuZGxlciwgSUhhbmRsZXJIb3N0IH0gZnJvbSAnLi4vYXNzZXQtaGFuZGxlcic7XG5pbXBvcnQgeyBwYXRoRXhpc3RzIH0gZnJvbSAnLi4vZnMtZXh0cmEnO1xuaW1wb3J0IHsgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyB9IGZyb20gJy4uL3BsYWNlaG9sZGVycyc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4uL3NoZWxsJztcblxuLyoqXG4gKiBUaGUgc2l6ZSBvZiBhbiBlbXB0eSB6aXAgZmlsZSBpcyAyMiBieXRlc1xuICpcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWklQXyhmaWxlX2Zvcm1hdClcbiAqL1xuY29uc3QgRU1QVFlfWklQX0ZJTEVfU0laRSA9IDIyO1xuXG5leHBvcnQgY2xhc3MgRmlsZUFzc2V0SGFuZGxlciBpbXBsZW1lbnRzIElBc3NldEhhbmRsZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGZpbGVDYWNoZVJvb3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHdvcmtEaXI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0OiBGaWxlTWFuaWZlc3RFbnRyeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElIYW5kbGVySG9zdFxuICApIHtcbiAgICB0aGlzLmZpbGVDYWNoZVJvb3QgPSBwYXRoLmpvaW4od29ya0RpciwgJy5jYWNoZScpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1aWxkKCk6IFByb21pc2U8dm9pZD4ge31cblxuICBwdWJsaWMgYXN5bmMgaXNQdWJsaXNoZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBhd2FpdCByZXBsYWNlQXdzUGxhY2Vob2xkZXJzKHRoaXMuYXNzZXQuZGVzdGluYXRpb24sIHRoaXMuaG9zdC5hd3MpO1xuICAgIGNvbnN0IHMzVXJsID0gYHMzOi8vJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfS8ke2Rlc3RpbmF0aW9uLm9iamVjdEtleX1gO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzMyA9IGF3YWl0IHRoaXMuaG9zdC5hd3MuczNDbGllbnQoe1xuICAgICAgICAuLi5kZXN0aW5hdGlvblRvQ2xpZW50T3B0aW9ucyhkZXN0aW5hdGlvbiksXG4gICAgICAgIHF1aWV0OiB0cnVlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNIRUNLLCBgQ2hlY2sgJHtzM1VybH1gKTtcblxuICAgICAgaWYgKGF3YWl0IG9iamVjdEV4aXN0cyhzMywgZGVzdGluYXRpb24uYnVja2V0TmFtZSwgZGVzdGluYXRpb24ub2JqZWN0S2V5KSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkZPVU5ELCBgRm91bmQgJHtzM1VybH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBgJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdWJsaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBzM1VybCA9IGBzMzovLyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0vJHtkZXN0aW5hdGlvbi5vYmplY3RLZXl9YDtcblxuICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBkZXN0aW5hdGlvblRvQ2xpZW50T3B0aW9ucyhkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLmhvc3QuYXdzLnMzQ2xpZW50KGNsaWVudE9wdGlvbnMpO1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke3MzVXJsfWApO1xuXG4gICAgY29uc3QgYnVja2V0SW5mbyA9IEJ1Y2tldEluZm9ybWF0aW9uLmZvcih0aGlzLmhvc3QpO1xuXG4gICAgLy8gQSB0aHVuayBmb3IgZGVzY3JpYmluZyB0aGUgY3VycmVudCBhY2NvdW50LiBVc2VkIHdoZW4gd2UgbmVlZCB0byBmb3JtYXQgYW4gZXJyb3JcbiAgICAvLyBtZXNzYWdlLCBub3QgaW4gdGhlIHN1Y2Nlc3MgY2FzZS5cbiAgICBjb25zdCBhY2NvdW50ID0gYXN5bmMgKCkgPT5cbiAgICAgIChhd2FpdCB0aGlzLmhvc3QuYXdzLmRpc2NvdmVyVGFyZ2V0QWNjb3VudChjbGllbnRPcHRpb25zKSk/LmFjY291bnRJZDtcbiAgICBzd2l0Y2ggKGF3YWl0IGJ1Y2tldEluZm8uYnVja2V0T3duZXJzaGlwKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKSkge1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuTUlORTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YFxuICAgICAgICApO1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1M6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQnVja2V0IG5hbWVkICcke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9JyBleGlzdHMsIGJ1dCBub3QgaW4gYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0uIFdyb25nIGFjY291bnQ/YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBvYmplY3RFeGlzdHMoczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsIGRlc3RpbmF0aW9uLm9iamVjdEtleSkpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke3MzVXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZ5IHRoZSB0aGUgYnVja2V0IGVuY3J5cHRpb24gdHlwZSB0byBzZXQgdGhlIGhlYWRlciBvbiB1cGxvYWRcbiAgICAvLyByZXF1aXJlZCBmb3IgU0NQIHJ1bGVzIGRlbnlpbmcgdXBsb2FkcyB3aXRob3V0IGVuY3J5cHRpb24gaGVhZGVyXG4gICAgbGV0IHBhcmFtc0VuY3J5cHRpb246IHsgW2luZGV4OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIGNvbnN0IGVuY3J5cHRpb24yID0gYXdhaXQgYnVja2V0SW5mby5idWNrZXRFbmNyeXB0aW9uKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKTtcbiAgICBzd2l0Y2ggKGVuY3J5cHRpb24yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25vX2VuY3J5cHRpb24nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FlczI1Nic6XG4gICAgICAgIHBhcmFtc0VuY3J5cHRpb24gPSB7IFNlcnZlclNpZGVFbmNyeXB0aW9uOiAnQUVTMjU2JyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ttcyc6XG4gICAgICAgIC8vIFdlIG11c3QgaW5jbHVkZSB0aGUga2V5IElEIG90aGVyd2lzZSBTMyB3aWxsIGVuY3J5cHQgd2l0aCB0aGUgZGVmYXVsdCBrZXlcbiAgICAgICAgcGFyYW1zRW5jcnlwdGlvbiA9IHtcbiAgICAgICAgICBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ2F3czprbXMnLFxuICAgICAgICAgIFNTRUtNU0tleUlkOiBlbmNyeXB0aW9uMi5rbXNLZXlJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb2VzX25vdF9leGlzdCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShcbiAgICAgICAgICBFdmVudFR5cGUuREVCVUcsXG4gICAgICAgICAgYE5vIGJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScuIElzIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9IGJvb3RzdHJhcHBlZD9gXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWNjZXNzX2RlbmllZCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShcbiAgICAgICAgICBFdmVudFR5cGUuREVCVUcsXG4gICAgICAgICAgYENvdWxkIG5vdCByZWFkIGVuY3J5cHRpb24gc2V0dGluZ3Mgb2YgYnVja2V0ICcke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9JzogdXBsb2FkaW5nIHdpdGggZGVmYXVsdCBzZXR0aW5ncyAoXCJjZGsgYm9vdHN0cmFwXCIgdG8gdmVyc2lvbiA5IGlmIHlvdXIgb3JnYW5pemF0aW9uJ3MgcG9saWNpZXMgcHJldmVudCBhIHN1Y2Nlc3NmdWwgdXBsb2FkIG9yIHRvIGdldCByaWQgb2YgdGhpcyBtZXNzYWdlKS5gXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaXNoRmlsZSA9IHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGVcbiAgICAgID8gYXdhaXQgdGhpcy5leHRlcm5hbFBhY2thZ2VGaWxlKHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpXG4gICAgICA6IGF3YWl0IHRoaXMucGFja2FnZUZpbGUodGhpcy5hc3NldC5zb3VyY2UpO1xuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBVcGxvYWQgJHtzM1VybH1gKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgQnVja2V0OiBkZXN0aW5hdGlvbi5idWNrZXROYW1lLFxuICAgICAgICBLZXk6IGRlc3RpbmF0aW9uLm9iamVjdEtleSxcbiAgICAgICAgQm9keTogY3JlYXRlUmVhZFN0cmVhbShwdWJsaXNoRmlsZS5wYWNrYWdlZFBhdGgpLFxuICAgICAgICBDb250ZW50VHlwZTogcHVibGlzaEZpbGUuY29udGVudFR5cGUsXG4gICAgICB9LFxuICAgICAgcGFyYW1zRW5jcnlwdGlvblxuICAgICk7XG5cbiAgICBhd2FpdCBzMy51cGxvYWQocGFyYW1zKS5wcm9taXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhY2thZ2VGaWxlKHNvdXJjZTogRmlsZVNvdXJjZSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICBpZiAoIXNvdXJjZS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAncGF0aCcgaXMgZXhwZWN0ZWQgaW4gdGhlIEZpbGUgYXNzZXQgc291cmNlLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoc291cmNlKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya0Rpciwgc291cmNlLnBhdGgpO1xuXG4gICAgaWYgKHNvdXJjZS5wYWNrYWdpbmcgPT09IEZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZKSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi96aXAnO1xuXG4gICAgICBhd2FpdCBmcy5ta2Rpcih0aGlzLmZpbGVDYWNoZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFja2FnZWRQYXRoID0gcGF0aC5qb2luKHRoaXMuZmlsZUNhY2hlUm9vdCwgYCR7dGhpcy5hc3NldC5pZC5hc3NldElkfS56aXBgKTtcblxuICAgICAgaWYgKGF3YWl0IHBhdGhFeGlzdHMocGFja2FnZWRQYXRoKSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNBQ0hFRCwgYEZyb20gY2FjaGUgJHtwYWNrYWdlZFBhdGh9YCk7XG4gICAgICAgIHJldHVybiB7IHBhY2thZ2VkUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYFppcCAke2Z1bGxQYXRofSAtPiAke3BhY2thZ2VkUGF0aH1gKTtcbiAgICAgIGF3YWl0IHppcERpcmVjdG9yeShmdWxsUGF0aCwgcGFja2FnZWRQYXRoLCAobSkgPT4gdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5ERUJVRywgbSkpO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IG1pbWUuZ2V0VHlwZShmdWxsUGF0aCkgPz8gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGg6IGZ1bGxQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZXh0ZXJuYWxQYWNrYWdlRmlsZShleGVjdXRhYmxlOiBzdHJpbmdbXSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgQnVpbGRpbmcgYXNzZXQgc291cmNlIHVzaW5nIGNvbW1hbmQ6ICcke2V4ZWN1dGFibGV9J2ApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2thZ2VkUGF0aDogKGF3YWl0IHNoZWxsKGV4ZWN1dGFibGUsIHsgcXVpZXQ6IHRydWUgfSkpLnRyaW0oKSxcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICB9O1xuICB9XG59XG5cbmVudW0gQnVja2V0T3duZXJzaGlwIHtcbiAgRE9FU19OT1RfRVhJU1QsXG4gIE1JTkUsXG4gIFNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTLFxufVxuXG50eXBlIEJ1Y2tldEVuY3J5cHRpb24gPVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ25vX2VuY3J5cHRpb24nIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdhZXMyNTYnIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdrbXMnOyByZWFkb25seSBrbXNLZXlJZD86IHN0cmluZyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnYWNjZXNzX2RlbmllZCcgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2RvZXNfbm90X2V4aXN0JyB9O1xuXG5hc3luYyBmdW5jdGlvbiBvYmplY3RFeGlzdHMoczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcsIGtleTogc3RyaW5nKSB7XG4gIC8qXG4gICAqIFRoZSBvYmplY3QgZXhpc3RlbmNlIGNoZWNrIGhlcmUgcmVmcmFpbnMgZnJvbSB1c2luZyB0aGUgYGhlYWRPYmplY3RgIG9wZXJhdGlvbiBiZWNhdXNlIHRoaXNcbiAgICogd291bGQgY3JlYXRlIGEgbmVnYXRpdmUgY2FjaGUgZW50cnksIG1ha2luZyBHRVQtYWZ0ZXItUFVUIGV2ZW50dWFsbHkgY29uc2lzdGVudC4gVGhpcyBoYXMgYmVlblxuICAgKiBvYnNlcnZlZCB0byByZXN1bHQgaW4gQ2xvdWRGb3JtYXRpb24gaXNzdWluZyBcIlZhbGlkYXRpb25FcnJvcjogUzMgZXJyb3I6IEFjY2VzcyBEZW5pZWRcIiwgZm9yXG4gICAqIGV4YW1wbGUgaW4gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy82NDMwLlxuICAgKlxuICAgKiBUbyBwcmV2ZW50IHRoaXMsIHdlIGFyZSBpbnN0ZWFkIHVzaW5nIHRoZSBsaXN0T2JqZWN0c1YyIGNhbGwsIHVzaW5nIHRoZSBsb29rZWQgdXAga2V5IGFzIHRoZVxuICAgKiBwcmVmaXgsIGFuZCBsaW1pdGluZyByZXN1bHRzIHRvIDEuIFNpbmNlIHRoZSBsaXN0IG9wZXJhdGlvbiByZXR1cm5zIGtleXMgb3JkZXJlZCBieSBiaW5hcnlcbiAgICogVVRGLTggcmVwcmVzZW50YXRpb24sIHRoZSBrZXkgd2UgYXJlIGxvb2tpbmcgZm9yIGlzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRoZSBmaXJzdCBtYXRjaFxuICAgKiByZXR1cm5lZCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIElmIHRoZSBmaWxlIGlzIHRvbyBzbWFsbCwgd2UgZGlzY291bnQgaXQgYXMgYSBjYWNoZSBoaXQuIFRoZXJlIGlzIGFuIGlzc3VlXG4gICAqIHNvbWV3aGVyZSB0aGF0IHNvbWV0aW1lcyBwcm9kdWNlcyBlbXB0eSB6aXAgZmlsZXMsIGFuZCB3ZSB3b3VsZCBvdGhlcndpc2VcbiAgICogbmV2ZXIgcmV0cnkgYnVpbGRpbmcgdGhvc2UgYXNzZXRzIHdpdGhvdXQgdXNlcnMgaGF2aW5nIHRvIG1hbnVhbGx5IGNsZWFyXG4gICAqIHRoZWlyIGJ1Y2tldCwgd2hpY2ggaXMgYSBiYWQgZXhwZXJpZW5jZS5cbiAgICovXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgczMubGlzdE9iamVjdHNWMih7IEJ1Y2tldDogYnVja2V0LCBQcmVmaXg6IGtleSwgTWF4S2V5czogMSB9KS5wcm9taXNlKCk7XG4gIHJldHVybiAoXG4gICAgcmVzcG9uc2UuQ29udGVudHMgIT0gbnVsbCAmJlxuICAgIHJlc3BvbnNlLkNvbnRlbnRzLnNvbWUoXG4gICAgICAob2JqZWN0KSA9PiBvYmplY3QuS2V5ID09PSBrZXkgJiYgKG9iamVjdC5TaXplID09IG51bGwgfHwgb2JqZWN0LlNpemUgPiBFTVBUWV9aSVBfRklMRV9TSVpFKVxuICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBBIHBhY2thZ2VkIGFzc2V0IHdoaWNoIGNhbiBiZSB1cGxvYWRlZCAoZWl0aGVyIGEgc2luZ2xlIGZpbGUgb3IgZGlyZWN0b3J5KVxuICovXG5pbnRlcmZhY2UgUGFja2FnZWRGaWxlQXNzZXQge1xuICAvKipcbiAgICogUGF0aCBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAgICovXG4gIHJlYWRvbmx5IHBhY2thZ2VkUGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb250ZW50IHR5cGUgdG8gYmUgYWRkZWQgaW4gdGhlIFMzIHVwbG9hZCBhY3Rpb25cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBjb250ZW50IHR5cGVcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRlbnRUeXBlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIENhY2hlIGZvciBidWNrZXQgaW5mb3JtYXRpb24sIHNvIHdlIGRvbid0IGhhdmUgdG8ga2VlcCBkb2luZyB0aGUgc2FtZSBjYWxscyBhZ2FpbiBhbmQgYWdhaW5cbiAqXG4gKiBXZSBzY29wZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIHRoZSBsaWZldGltZSBvZiB0aGUgaG9zdCwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvXG4gKiBhbnl0aGluZyBzcGVjaWFsIGZvciB0ZXN0cyBhbmQgeWV0IHRoZSBjYWNoZSB3aWxsIGxpdmUgZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFzc2V0XG4gKiB1cGxvYWQgc2Vzc2lvbiB3aGVuIHVzZWQgYnkgdGhlIENMSS5cbiAqL1xuY2xhc3MgQnVja2V0SW5mb3JtYXRpb24ge1xuICBwdWJsaWMgc3RhdGljIGZvcihob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5nZXQoaG9zdCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuXG4gICAgY29uc3QgZnJlc2ggPSBuZXcgQnVja2V0SW5mb3JtYXRpb24oKTtcbiAgICBCdWNrZXRJbmZvcm1hdGlvbi5jYWNoZXMuc2V0KGhvc3QsIGZyZXNoKTtcbiAgICByZXR1cm4gZnJlc2g7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjYWNoZXMgPSBuZXcgV2Vha01hcDxJSGFuZGxlckhvc3QsIEJ1Y2tldEluZm9ybWF0aW9uPigpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXJzaGlwcyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRPd25lcnNoaXA+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQnVja2V0RW5jcnlwdGlvbj4oKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICBwdWJsaWMgYXN5bmMgYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMub3duZXJzaGlwcywgYnVja2V0LCAoKSA9PiB0aGlzLl9idWNrZXRPd25lcnNoaXAoczMsIGJ1Y2tldCkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldEVuY3J5cHRpb24oczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMuZW5jcnlwdGlvbnMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0RW5jcnlwdGlvbihzMywgYnVja2V0KSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9idWNrZXRPd25lcnNoaXAoczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldE93bmVyc2hpcD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzMy5nZXRCdWNrZXRMb2NhdGlvbih7IEJ1Y2tldDogYnVja2V0IH0pLnByb21pc2UoKTtcbiAgICAgIHJldHVybiBCdWNrZXRPd25lcnNoaXAuTUlORTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdOb1N1Y2hCdWNrZXQnKSB7XG4gICAgICAgIHJldHVybiBCdWNrZXRPd25lcnNoaXAuRE9FU19OT1RfRVhJU1Q7XG4gICAgICB9XG4gICAgICBpZiAoWydBY2Nlc3NEZW5pZWQnLCAnQWxsQWNjZXNzRGlzYWJsZWQnXS5pbmNsdWRlcyhlLmNvZGUpKSB7XG4gICAgICAgIHJldHVybiBCdWNrZXRPd25lcnNoaXAuU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1M7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2J1Y2tldEVuY3J5cHRpb24oczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jcnlwdGlvbiA9IGF3YWl0IHMzLmdldEJ1Y2tldEVuY3J5cHRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBsID0gZW5jcnlwdGlvbj8uU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uPy5SdWxlcz8ubGVuZ3RoID8/IDA7XG4gICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgY29uc3QgYXBwbHkgPVxuICAgICAgICAgIGVuY3J5cHRpb24/LlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvbj8uUnVsZXNbMF1cbiAgICAgICAgICAgID8uQXBwbHlTZXJ2ZXJTaWRlRW5jcnlwdGlvbkJ5RGVmYXVsdDtcbiAgICAgICAgbGV0IHNzZWFsZ28gPSBhcHBseT8uU1NFQWxnb3JpdGhtO1xuICAgICAgICBpZiAoc3NlYWxnbyA9PT0gJ0FFUzI1NicpIHJldHVybiB7IHR5cGU6ICdhZXMyNTYnIH07XG4gICAgICAgIGlmIChzc2VhbGdvID09PSAnYXdzOmttcycpIHJldHVybiB7IHR5cGU6ICdrbXMnLCBrbXNLZXlJZDogYXBwbHk/LktNU01hc3RlcktleUlEIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdOb1N1Y2hCdWNrZXQnKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdkb2VzX25vdF9leGlzdCcgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlLmNvZGUgPT09ICdTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25Ob3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnYWNjZXNzX2RlbmllZCcgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9O1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWNoZWQ8QSwgQj4oY2FjaGU6IE1hcDxBLCBCPiwga2V5OiBBLCBmYWN0b3J5OiAoeDogQSkgPT4gUHJvbWlzZTxCPik6IFByb21pc2U8Qj4ge1xuICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSkhO1xuICB9XG5cbiAgY29uc3QgZnJlc2ggPSBhd2FpdCBmYWN0b3J5KGtleSk7XG4gIGNhY2hlLnNldChrZXksIGZyZXNoKTtcbiAgcmV0dXJuIGZyZXNoO1xufVxuIl19