"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipDirectory = zipDirectory;
const fs_1 = require("fs");
const path = require("path");
const glob = require("glob");
// namespace object imports won't work in the bundle for function exports
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
async function zipDirectory(directory, outputFile, logger) {
    // We write to a temporary file and rename at the last moment. This is so that if we are
    // interrupted during this process, we don't leave a half-finished file in the target location.
    const temporaryOutputFile = `${outputFile}.${randomString()}._tmp`;
    await writeZipFile(directory, temporaryOutputFile);
    await moveIntoPlace(temporaryOutputFile, outputFile, logger);
}
function writeZipFile(directory, outputFile) {
    return new Promise(async (ok, fail) => {
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            cwd: directory,
        };
        const files = glob.sync('**', globOptions); // The output here is already sorted
        const output = (0, fs_1.createWriteStream)(outputFile);
        const archive = archiver('zip');
        archive.on('warning', fail);
        archive.on('error', fail);
        // archive has been finalized and the output file descriptor has closed, resolve promise
        // this has to be done before calling `finalize` since the events may fire immediately after.
        // see https://www.npmjs.com/package/archiver
        output.once('close', ok);
        archive.pipe(output);
        // Append files serially to ensure file order
        for (const file of files) {
            const fullPath = path.resolve(directory, file);
            const [data, stat] = await Promise.all([fs_1.promises.readFile(fullPath), fs_1.promises.stat(fullPath)]);
            archive.append(data, {
                name: file,
                date: new Date('1980-01-01T00:00:00.000Z'), // reset dates to get the same hash for the same content
                mode: stat.mode,
            });
        }
        await archive.finalize();
    });
}
/**
 * Rename the file to the target location, taking into account:
 *
 * - That we may see EPERM on Windows while an Antivirus scanner still has the
 *   file open, so retry a couple of times.
 * - This same function may be called in parallel and be interrupted at any point.
 */
async function moveIntoPlace(source, target, logger) {
    let delay = 100;
    let attempts = 5;
    while (true) {
        try {
            // 'rename' is guaranteed to overwrite an existing target, as long as it is a file (not a directory)
            await fs_1.promises.rename(source, target);
            return;
        }
        catch (e) {
            if (e.code !== 'EPERM' || attempts-- <= 0) {
                throw e;
            }
            logger(e.message);
            await sleep(Math.floor(Math.random() * delay));
            delay *= 2;
        }
    }
}
function sleep(ms) {
    return new Promise((ok) => setTimeout(ok, ms));
}
function randomString() {
    return Math.random()
        .toString(36)
        .replace(/[^a-z0-9]+/g, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFyY2hpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFVQSxvQ0FVQztBQXBCRCwyQkFBdUQ7QUFDdkQsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUU3Qix5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUk5QixLQUFLLFVBQVUsWUFBWSxDQUNoQyxTQUFpQixFQUNqQixVQUFrQixFQUNsQixNQUFjO0lBRWQsd0ZBQXdGO0lBQ3hGLCtGQUErRjtJQUMvRixNQUFNLG1CQUFtQixHQUFHLEdBQUcsVUFBVSxJQUFJLFlBQVksRUFBRSxPQUFPLENBQUM7SUFDbkUsTUFBTSxZQUFZLENBQUMsU0FBUyxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDbkQsTUFBTSxhQUFhLENBQUMsbUJBQW1CLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxTQUFpQixFQUFFLFVBQWtCO0lBQ3pELE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUNwQyxzRkFBc0Y7UUFDdEYsaUZBQWlGO1FBQ2pGLGlFQUFpRTtRQUNqRSxNQUFNLFdBQVcsR0FBRztZQUNsQixHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxJQUFJO1lBQ1gsTUFBTSxFQUFFLElBQUk7WUFDWixHQUFHLEVBQUUsU0FBUztTQUNmLENBQUM7UUFDRixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLG9DQUFvQztRQUVoRixNQUFNLE1BQU0sR0FBRyxJQUFBLHNCQUFpQixFQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTdDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoQyxPQUFPLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM1QixPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUxQix3RkFBd0Y7UUFDeEYsNkZBQTZGO1FBQzdGLDZDQUE2QztRQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV6QixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXJCLDZDQUE2QztRQUM3QyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ3pCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQy9DLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsYUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxhQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRixPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtnQkFDbkIsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsd0RBQXdEO2dCQUNwRyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7YUFDaEIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELE1BQU0sT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILEtBQUssVUFBVSxhQUFhLENBQUMsTUFBYyxFQUFFLE1BQWMsRUFBRSxNQUFjO0lBQ3pFLElBQUksS0FBSyxHQUFHLEdBQUcsQ0FBQztJQUNoQixJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7SUFDakIsT0FBTyxJQUFJLEVBQUUsQ0FBQztRQUNaLElBQUksQ0FBQztZQUNILG9HQUFvRztZQUNwRyxNQUFNLGFBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2hDLE9BQU87UUFDVCxDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssT0FBTyxJQUFJLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUMxQyxNQUFNLENBQUMsQ0FBQztZQUNWLENBQUM7WUFDRCxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDL0MsS0FBSyxJQUFJLENBQUMsQ0FBQztRQUNiLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsS0FBSyxDQUFDLEVBQVU7SUFDdkIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFFRCxTQUFTLFlBQVk7SUFDbkIsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFO1NBQ2pCLFFBQVEsQ0FBQyxFQUFFLENBQUM7U0FDWixPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVXcml0ZVN0cmVhbSwgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgZ2xvYiBmcm9tICdnbG9iJztcblxuLy8gbmFtZXNwYWNlIG9iamVjdCBpbXBvcnRzIHdvbid0IHdvcmsgaW4gdGhlIGJ1bmRsZSBmb3IgZnVuY3Rpb24gZXhwb3J0c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbmNvbnN0IGFyY2hpdmVyID0gcmVxdWlyZSgnYXJjaGl2ZXInKTtcblxudHlwZSBMb2dnZXIgPSAoeDogc3RyaW5nKSA9PiB2b2lkO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gemlwRGlyZWN0b3J5KFxuICBkaXJlY3Rvcnk6IHN0cmluZyxcbiAgb3V0cHV0RmlsZTogc3RyaW5nLFxuICBsb2dnZXI6IExvZ2dlclxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFdlIHdyaXRlIHRvIGEgdGVtcG9yYXJ5IGZpbGUgYW5kIHJlbmFtZSBhdCB0aGUgbGFzdCBtb21lbnQuIFRoaXMgaXMgc28gdGhhdCBpZiB3ZSBhcmVcbiAgLy8gaW50ZXJydXB0ZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcywgd2UgZG9uJ3QgbGVhdmUgYSBoYWxmLWZpbmlzaGVkIGZpbGUgaW4gdGhlIHRhcmdldCBsb2NhdGlvbi5cbiAgY29uc3QgdGVtcG9yYXJ5T3V0cHV0RmlsZSA9IGAke291dHB1dEZpbGV9LiR7cmFuZG9tU3RyaW5nKCl9Ll90bXBgO1xuICBhd2FpdCB3cml0ZVppcEZpbGUoZGlyZWN0b3J5LCB0ZW1wb3JhcnlPdXRwdXRGaWxlKTtcbiAgYXdhaXQgbW92ZUludG9QbGFjZSh0ZW1wb3JhcnlPdXRwdXRGaWxlLCBvdXRwdXRGaWxlLCBsb2dnZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVppcEZpbGUoZGlyZWN0b3J5OiBzdHJpbmcsIG91dHB1dEZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKG9rLCBmYWlsKSA9PiB7XG4gICAgLy8gVGhlIGJlbG93IG9wdGlvbnMgYXJlIG5lZWRlZCB0byBzdXBwb3J0IGZvbGxvd2luZyBzeW1saW5rcyB3aGVuIGJ1aWxkaW5nIHppcCBmaWxlczpcbiAgICAvLyAtIG5vZGlyOiBUaGlzIHdpbGwgcHJldmVudCBzeW1saW5rcyB0aGVtc2VsdmVzIGZyb20gYmVpbmcgY29waWVkIGludG8gdGhlIHppcC5cbiAgICAvLyAtIGZvbGxvdzogVGhpcyB3aWxsIGZvbGxvdyBzeW1saW5rcyBhbmQgY29weSB0aGUgZmlsZXMgd2l0aGluLlxuICAgIGNvbnN0IGdsb2JPcHRpb25zID0ge1xuICAgICAgZG90OiB0cnVlLFxuICAgICAgbm9kaXI6IHRydWUsXG4gICAgICBmb2xsb3c6IHRydWUsXG4gICAgICBjd2Q6IGRpcmVjdG9yeSxcbiAgICB9O1xuICAgIGNvbnN0IGZpbGVzID0gZ2xvYi5zeW5jKCcqKicsIGdsb2JPcHRpb25zKTsgLy8gVGhlIG91dHB1dCBoZXJlIGlzIGFscmVhZHkgc29ydGVkXG5cbiAgICBjb25zdCBvdXRwdXQgPSBjcmVhdGVXcml0ZVN0cmVhbShvdXRwdXRGaWxlKTtcblxuICAgIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJyk7XG4gICAgYXJjaGl2ZS5vbignd2FybmluZycsIGZhaWwpO1xuICAgIGFyY2hpdmUub24oJ2Vycm9yJywgZmFpbCk7XG5cbiAgICAvLyBhcmNoaXZlIGhhcyBiZWVuIGZpbmFsaXplZCBhbmQgdGhlIG91dHB1dCBmaWxlIGRlc2NyaXB0b3IgaGFzIGNsb3NlZCwgcmVzb2x2ZSBwcm9taXNlXG4gICAgLy8gdGhpcyBoYXMgdG8gYmUgZG9uZSBiZWZvcmUgY2FsbGluZyBgZmluYWxpemVgIHNpbmNlIHRoZSBldmVudHMgbWF5IGZpcmUgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgLy8gc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2FyY2hpdmVyXG4gICAgb3V0cHV0Lm9uY2UoJ2Nsb3NlJywgb2spO1xuXG4gICAgYXJjaGl2ZS5waXBlKG91dHB1dCk7XG5cbiAgICAvLyBBcHBlbmQgZmlsZXMgc2VyaWFsbHkgdG8gZW5zdXJlIGZpbGUgb3JkZXJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGRpcmVjdG9yeSwgZmlsZSk7XG4gICAgICBjb25zdCBbZGF0YSwgc3RhdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbZnMucmVhZEZpbGUoZnVsbFBhdGgpLCBmcy5zdGF0KGZ1bGxQYXRoKV0pO1xuICAgICAgYXJjaGl2ZS5hcHBlbmQoZGF0YSwge1xuICAgICAgICBuYW1lOiBmaWxlLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgnMTk4MC0wMS0wMVQwMDowMDowMC4wMDBaJyksIC8vIHJlc2V0IGRhdGVzIHRvIGdldCB0aGUgc2FtZSBoYXNoIGZvciB0aGUgc2FtZSBjb250ZW50XG4gICAgICAgIG1vZGU6IHN0YXQubW9kZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGF3YWl0IGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVuYW1lIHRoZSBmaWxlIHRvIHRoZSB0YXJnZXQgbG9jYXRpb24sIHRha2luZyBpbnRvIGFjY291bnQ6XG4gKlxuICogLSBUaGF0IHdlIG1heSBzZWUgRVBFUk0gb24gV2luZG93cyB3aGlsZSBhbiBBbnRpdmlydXMgc2Nhbm5lciBzdGlsbCBoYXMgdGhlXG4gKiAgIGZpbGUgb3Blbiwgc28gcmV0cnkgYSBjb3VwbGUgb2YgdGltZXMuXG4gKiAtIFRoaXMgc2FtZSBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGluIHBhcmFsbGVsIGFuZCBiZSBpbnRlcnJ1cHRlZCBhdCBhbnkgcG9pbnQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1vdmVJbnRvUGxhY2Uoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nLCBsb2dnZXI6IExvZ2dlcikge1xuICBsZXQgZGVsYXkgPSAxMDA7XG4gIGxldCBhdHRlbXB0cyA9IDU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vICdyZW5hbWUnIGlzIGd1YXJhbnRlZWQgdG8gb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHRhcmdldCwgYXMgbG9uZyBhcyBpdCBpcyBhIGZpbGUgKG5vdCBhIGRpcmVjdG9yeSlcbiAgICAgIGF3YWl0IGZzLnJlbmFtZShzb3VyY2UsIHRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnRVBFUk0nIHx8IGF0dGVtcHRzLS0gPD0gMCkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgbG9nZ2VyKGUubWVzc2FnZSk7XG4gICAgICBhd2FpdCBzbGVlcChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBkZWxheSkpO1xuICAgICAgZGVsYXkgKj0gMjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKG9rKSA9PiBzZXRUaW1lb3V0KG9rLCBtcykpO1xufVxuXG5mdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgLnRvU3RyaW5nKDM2KVxuICAgIC5yZXBsYWNlKC9bXmEtejAtOV0rL2csICcnKTtcbn1cbiJdfQ==