"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bump = bump;
const fs_1 = require("fs");
const path_1 = require("path");
const semver_1 = require("semver");
const logging = require("../logging");
const util_1 = require("../util");
const version_1 = require("../version");
/**
 * Resolves the latest version from git tags and uses `commit-and-tag-version` to bump
 * to the next version based on commits.
 *
 * This expects `commit-and-tag-version` to be installed in the path.
 *
 * @param cwd working directory (git repository)
 * @param options options
 */
async function bump(cwd, options) {
    const versionFile = (0, path_1.join)(cwd, options.versionFile);
    const prerelease = options.prerelease;
    const major = options.majorVersion;
    const minor = options.minorVersion;
    const minMajorVersion = options.minMajorVersion;
    const prefix = options.tagPrefix ?? "";
    const bumpFile = (0, path_1.join)(cwd, options.bumpFile);
    const changelogFile = (0, path_1.join)(cwd, options.changelog);
    const releaseTagFile = (0, path_1.join)(cwd, options.releaseTagFile);
    const bumpPackage = options.bumpPackage ?? "commit-and-tag-version@^12";
    if (major && minMajorVersion) {
        throw new Error(`minMajorVersion and majorVersion cannot be used together.`);
    }
    if (minor && !major) {
        throw new Error(`minorVersion and majorVersion must be used together.`);
    }
    await fs_1.promises.mkdir((0, path_1.dirname)(bumpFile), { recursive: true });
    await fs_1.promises.mkdir((0, path_1.dirname)(changelogFile), { recursive: true });
    await fs_1.promises.mkdir((0, path_1.dirname)(releaseTagFile), { recursive: true });
    const { latestVersion, latestTag, isFirstRelease } = determineLatestTag({
        cwd,
        major,
        minor,
        prerelease,
        prefix,
    });
    const { contents, newline } = await tryReadVersionFile(versionFile);
    // update version
    contents.version = latestVersion;
    logging.info(`Update ${versionFile} to latest resolved version: ${latestVersion}`);
    await fs_1.promises.writeFile(versionFile, JSON.stringify(contents, undefined, 2) + (newline ? "\n" : ""));
    // check for commits since the last release tag
    let skipBump = false;
    // First Release is never skipping bump
    if (!isFirstRelease) {
        const findCommits = (options.releasableCommits ?? version_1.ReleasableCommits.everyCommit().cmd).replace("$LATEST_TAG", latestTag);
        const commitsSinceLastTag = (0, util_1.execOrUndefined)(findCommits, { cwd })?.split("\n");
        const numCommitsSinceLastTag = commitsSinceLastTag?.length ?? 0;
        logging.info(`Number of commits since ${latestTag}: ${numCommitsSinceLastTag}`);
        // Nothing to release right now
        if (numCommitsSinceLastTag === 0) {
            logging.info("Skipping bump...");
            skipBump = true;
            // delete the existing tag (locally)
            // if we don't do this, commit-and-tag-version generates an empty changelog
            (0, util_1.exec)(`git tag --delete ${latestTag}`, { cwd });
        }
    }
    // create a commit-and-tag-version configuration file
    const rcfile = (0, path_1.join)(cwd, ".versionrc.json");
    await generateVersionrcFile(rcfile, versionFile, changelogFile, skipBump, prerelease, options.versionrcOptions);
    const cmd = ["npx", bumpPackage];
    if (isFirstRelease && !minMajorVersion) {
        cmd.push("--first-release");
    }
    if (prefix) {
        cmd.push(`--tag-prefix ${prefix}v`);
    }
    if (minMajorVersion) {
        const [majorVersion] = latestVersion.split(".");
        const majorVersionNumber = parseInt(majorVersion, 10);
        if (majorVersionNumber < minMajorVersion) {
            cmd.push(`--release-as ${minMajorVersion}.0.0`);
        }
    }
    (0, util_1.exec)(cmd.join(" "), { cwd });
    // add the tag back if it was previously removed
    if (skipBump) {
        (0, util_1.exec)(`git tag ${latestTag}`, { cwd });
    }
    await fs_1.promises.rm(rcfile, { force: true, recursive: true });
    const newVersion = (await tryReadVersionFile(versionFile)).version;
    if (!newVersion) {
        throw new Error(`bump failed: ${versionFile} does not have a version set`);
    }
    // if MAJOR is defined, ensure that the new version is within the same major version
    if (major) {
        if (!newVersion.startsWith(`${major}.`)) {
            throw new Error(`bump failed: this branch is configured to only publish v${major} releases - bump resulted in ${newVersion}`);
        }
    }
    if (minor) {
        if (!newVersion.startsWith(`${major}.${minor}`)) {
            throw new Error(`bump failed: this branch is configured to only publish v${major}.${minor} releases - bump resulted in ${newVersion}`);
        }
    }
    await fs_1.promises.writeFile(bumpFile, newVersion);
    const newTag = `${prefix}v${newVersion}`;
    await fs_1.promises.writeFile(releaseTagFile, newTag);
}
async function tryReadVersionFile(versionFile) {
    if (!(0, fs_1.existsSync)(versionFile)) {
        return { contents: {}, newline: true };
    }
    const raw = await fs_1.promises.readFile(versionFile, "utf-8");
    const contents = JSON.parse(raw);
    return {
        contents,
        version: contents.version,
        newline: raw.endsWith("\n"),
    };
}
function generateVersionrcFile(rcfile, versionFile, changelogFile, skipBump, prerelease, configOptions) {
    return fs_1.promises.writeFile(rcfile, JSON.stringify({
        ...{
            packageFiles: [
                {
                    filename: versionFile,
                    type: "json",
                },
            ],
            bumpFiles: [
                {
                    filename: versionFile,
                    type: "json",
                },
            ],
            commitAll: false,
            infile: changelogFile,
            prerelease: prerelease,
            header: "",
            skip: {
                commit: true,
                tag: true,
                bump: skipBump,
            },
            ...configOptions,
        },
    }, undefined, 2));
}
/**
 * Determines the latest release tag.
 * @param major (optional) A major version line to select from
 * @param prerelease (optional) A pre-release suffix.
 * @returns the latest tag, and whether it is the first release or not
 */
function determineLatestTag(options) {
    const { cwd, major, minor, prerelease, prefix } = options;
    // filter only tags for this prefix and major version if specified (start with "vNN.").
    let prefixFilter;
    if (major !== undefined && minor !== undefined) {
        prefixFilter = `${prefix}v${major}.${minor}.*`;
    }
    else if (major !== undefined) {
        prefixFilter = `${prefix}v${major}.*`;
    }
    else {
        prefixFilter = `${prefix}v*`;
    }
    const listGitTags = [
        "git",
        '-c "versionsort.suffix=-"', // makes sure pre-release versions are listed after the primary version
        "tag",
        '--sort="-version:refname"', // sort as versions and not lexicographically
        "--list",
        `"${prefixFilter}"`,
    ].join(" ");
    const stdout = (0, util_1.execCapture)(listGitTags, { cwd }).toString("utf8");
    let tags = stdout?.split("\n");
    // if prerelease is set and there are existing prerelease tags, filter versions that end with "-PRE.ddd".
    const prereleaseTags = tags.filter((x) => new RegExp(`-${prerelease}\.[0-9]+$`).test(x));
    if (prerelease && prereleaseTags.length > 0) {
        /**
         * Cover the following case specifically
         * 1 - v1.0.0
         * 2 - v1.0.1-beta.0
         * 3 - v1.0.1-beta.1
         * 4 - v1.0.1
         * 5 - now publish a new release on the prerelease branch
         *    by setting the latestTag as v1.0.1 instead of v1.0.1-beta.1
         */
        const releaseTags = tags.filter((x) => new RegExp(`^v([0-9]+)\.([0-9]+)\.([0-9]+)$`).test(x));
        if (releaseTags.length > 0 &&
            (0, semver_1.compare)(releaseTags[0], prereleaseTags[0]) === 1) {
            tags = releaseTags;
        }
        else {
            tags = prereleaseTags;
        }
    }
    tags = tags.filter((x) => x);
    // if a pre-release tag is used, then add it to the initial version
    let isFirstRelease = false;
    let latestTag;
    if (tags.length > 0) {
        latestTag = tags[0];
    }
    else {
        const initial = `${prefix}v${major ?? 0}.${minor ?? 0}.0`;
        latestTag = prerelease ? `${initial}-${prerelease}.0` : initial;
        isFirstRelease = true;
    }
    // remove tag prefix (if exists)
    let latestVersion = latestTag;
    if (prefix && latestVersion.startsWith(prefix)) {
        latestVersion = latestVersion.substr(prefix.length);
    }
    // remove "v" prefix (if exists)
    if (latestVersion.startsWith("v")) {
        latestVersion = latestVersion.substring(1);
    }
    return { latestVersion, latestTag, isFirstRelease };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVtcC12ZXJzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JlbGVhc2UvYnVtcC12ZXJzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBbUhBLG9CQXFJQztBQXhQRCwyQkFBZ0Q7QUFDaEQsK0JBQXFDO0FBRXJDLG1DQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEMsa0NBQTZEO0FBQzdELHdDQUErQztBQW9HL0M7Ozs7Ozs7O0dBUUc7QUFDSSxLQUFLLFVBQVUsSUFBSSxDQUFDLEdBQVcsRUFBRSxPQUFvQjtJQUMxRCxNQUFNLFdBQVcsR0FBRyxJQUFBLFdBQUksRUFBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ25ELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7SUFDdEMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztJQUNuQyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQ25DLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUM7SUFDaEQsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUM7SUFDdkMsTUFBTSxRQUFRLEdBQUcsSUFBQSxXQUFJLEVBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QyxNQUFNLGFBQWEsR0FBRyxJQUFBLFdBQUksRUFBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ25ELE1BQU0sY0FBYyxHQUFHLElBQUEsV0FBSSxFQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDekQsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsSUFBSSw0QkFBNEIsQ0FBQztJQUV4RSxJQUFJLEtBQUssSUFBSSxlQUFlLEVBQUUsQ0FBQztRQUM3QixNQUFNLElBQUksS0FBSyxDQUNiLDJEQUEyRCxD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Q0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByb21pc2VzIGFzIGZzLCBleGlzdHNTeW5jIH0gZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBkaXJuYW1lLCBqb2luIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IENvbmZpZyB9IGZyb20gXCJjb252ZW50aW9uYWwtY2hhbmdlbG9nLWNvbmZpZy1zcGVjXCI7XG5pbXBvcnQgeyBjb21wYXJlIH0gZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tIFwiLi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHsgZXhlYywgZXhlY0NhcHR1cmUsIGV4ZWNPclVuZGVmaW5lZCB9IGZyb20gXCIuLi91dGlsXCI7XG5pbXBvcnQgeyBSZWxlYXNhYmxlQ29tbWl0cyB9IGZyb20gXCIuLi92ZXJzaW9uXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVtcE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgYSAuanNvbiBmaWxlIHRvIHNldCBgdmVyc2lvbmAuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uRmlsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgY2hhbmdlbG9nIGZpbGUgdG8gZ2VuZXJhdGUuXG4gICAqL1xuICByZWFkb25seSBjaGFuZ2Vsb2c6IHN0cmluZztcblxuICAvKipcbiAgICogVXNlIGEgcHJlLXJlbGVhc2Ugc3VmZml4LlxuICAgKiBAZGVmYXVsdCAtIG5vcm1hbCB2ZXJzaW9uaW5nXG4gICAqL1xuICByZWFkb25seSBwcmVyZWxlYXNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBtYWpvciB2ZXJzaW9uIGxpbmUuIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgdGhlIGxhdGVzdCB2ZXJzaW9uXG4gICAqIGFuZCBhbHNvIGVuZm9yY2UgdGhhdCBuZXcgbWFqb3IgdmVyc2lvbnMgYXJlIG5vdCByZWxlYXNlZCBhY2NpZGVudGFsbHkuXG4gICAqXG4gICAqIENhbiBub3QgYmUgc2V0IHRvZ2V0aGVyIHdpdGggYG1pbk1ham9yVmVyc2lvbmAuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gYW55IHZlcnNpb24gaXMgc3VwcG9ydGVkXG4gICAqL1xuICByZWFkb25seSBtYWpvclZlcnNpb24/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIG1pbmltYWwgbWFqb3IgdmVyc2lvbi4gVGhpcyBpcyB1c2VkIGlmIHlvdSB3YW50IHRvIHN0YXJ0IHdpdGhcbiAgICogYSBzcGVjaWZpYyBtYWpvciB2ZXJzaW9uLCBhbmQgaW5jcmVtZW50IGZyb20gdGhlcmUgb24uXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBzZXQgdG8gMSwgYXMgYnJlYWtpbmcgY2hhbmdlcyBiZWZvcmUgdGhlIDEueCBtYWpvclxuICAgKiByZWxlYXNlIGFyZSBub3QgaW5jcmVtZW50aW5nIHRoZSBtYWpvciB2ZXJzaW9uIG51bWJlci5cbiAgICpcbiAgICogQ2FuIG5vdCBiZSBzZXQgdG9nZXRoZXIgd2l0aCBgbWFqb3JWZXJzaW9uYC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBtaW5pbXVtIHZlcnNpb24gaXMgYmVpbmcgZW5mb3JjZWRcbiAgICovXG4gIHJlYWRvbmx5IG1pbk1ham9yVmVyc2lvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbWlub3IgdmVyc2lvbiBsaW5lLiBUaGlzIGlzIHVzZWQgdG8gc2VsZWN0IHRoZSBsYXRlc3QgdmVyc2lvblxuICAgKiBhbmQgYWxzbyBlbmZvcmNlIHRoYXQgbmV3IG1pbm9yIHZlcnNpb25zIGFyZSBub3QgcmVsZWFzZWQgYWNjaWRlbnRhbGx5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGFueSB2ZXJzaW9uIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgcmVhZG9ubHkgbWlub3JWZXJzaW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiBhIGZpbGUgd2hpY2ggd2lsbCBpbmNsdWRlIHRoZSBvdXRwdXQgdmVyc2lvbiBudW1iZXIgKGEgdGV4dCBmaWxlKS5cbiAgICpcbiAgICogUmVsYXRpdmUgdG8gY3dkLlxuICAgKlxuICAgKiBAZXhhbXBsZSBcIi52ZXJzaW9uLnR4dFwiXG4gICAqL1xuICByZWFkb25seSBidW1wRmlsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB3aGljaCB3aWxsIGluY2x1ZGUgdGhlIHJlbGVhc2UgdGFnIChhIHRleHQgZmlsZSkuXG4gICAqXG4gICAqIFJlbGF0aXZlIHRvIGN3ZC5cbiAgICpcbiAgICogQGV4YW1wbGUgXCIucmVsZWFzZXRhZy50eHRcIlxuICAgKi9cbiAgcmVhZG9ubHkgcmVsZWFzZVRhZ0ZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHByZWZpeCBhcHBsaWVkIHRvIHJlbGVhc2UgdGFncy4gQnVtcHMgd2lsbCBiZSBtYWRlIGJhc2VkIG9uIHRoZSBsYXRlc3RcbiAgICogdmVyc2lvbiBmb3VuZCB3aXRoIHRoaXMgcHJlZml4LlxuICAgKi9cbiAgcmVhZG9ubHkgdGFnUHJlZml4Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIHZhbHVlcyB0aGF0IHdvdWxkIGFwcGVuZCB0byB2ZXJzaW9ucmMgZmlsZSBvciBvdmVyd3JpdGUgdmFsdWVzXG4gICAqIGNvbWluZyB0byB0aGF0IGZyb20gZGVmYXVsdCBvbmUuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9ucmNPcHRpb25zPzogQ29uZmlnO1xuXG4gIC8qKlxuICAgKiBBIHNoZWxsIGNvbW1hbmQgdG8gbGlzdCBhbGwgcmVsZWFzZSBjb21taXRzIHNpbmNlIHRoZSBsYXRlc3QgdGFnLlxuICAgKlxuICAgKiBBIG5ldyByZWxlYXNlIHdpbGwgYmUgaW5pdGlhdGVkLCBpZiB0aGUgbnVtYmVyIG9mIHJldHVybmVkIGNvbW1pdHMgaXMgZ3JlYXRlciB0aGFuIHplcm8uXG4gICAqXG4gICAqIGAkTEFURVNUX1RBR2Agd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBhY3R1YWwgbGF0ZXN0IHRhZyBmb3IgdGhlIGdpdmVuIHByZWZpeC5cbiAgICpcbiAgICogQGRlZmF1bHQgXCJnaXQgbG9nIC0tb25lbGluZSAkTEFURVNUX1RBRy4uSEVBRFwiXG4gICAqL1xuICByZWFkb25seSByZWxlYXNhYmxlQ29tbWl0cz86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGBjb21taXQtYW5kLXRhZy12ZXJzaW9uYCBjb21wYXRpYmxlIHBhY2thZ2UgdXNlZCB0byBidW1wIHRoZSBwYWNrYWdlIHZlcnNpb24sIGFzIGEgZGVwZW5kZW5jeSBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIGFueSBjb21wYXRpYmxlIHBhY2thZ2UgdmVyc2lvbiwgaW5jbHVkaW5nIHRoZSBkZXByZWNhdGVkIGBzdGFuZGFyZC12ZXJzaW9uQDlgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcImNvbW1pdC1hbmQtdGFnLXZlcnNpb25AMTJcIlxuICAgKi9cbiAgcmVhZG9ubHkgYnVtcFBhY2thZ2U/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIGxhdGVzdCB2ZXJzaW9uIGZyb20gZ2l0IHRhZ3MgYW5kIHVzZXMgYGNvbW1pdC1hbmQtdGFnLXZlcnNpb25gIHRvIGJ1bXBcbiAqIHRvIHRoZSBuZXh0IHZlcnNpb24gYmFzZWQgb24gY29tbWl0cy5cbiAqXG4gKiBUaGlzIGV4cGVjdHMgYGNvbW1pdC1hbmQtdGFnLXZlcnNpb25gIHRvIGJlIGluc3RhbGxlZCBpbiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gY3dkIHdvcmtpbmcgZGlyZWN0b3J5IChnaXQgcmVwb3NpdG9yeSlcbiAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1bXAoY3dkOiBzdHJpbmcsIG9wdGlvbnM6IEJ1bXBPcHRpb25zKSB7XG4gIGNvbnN0IHZlcnNpb25GaWxlID0gam9pbihjd2QsIG9wdGlvbnMudmVyc2lvbkZpbGUpO1xuICBjb25zdCBwcmVyZWxlYXNlID0gb3B0aW9ucy5wcmVyZWxlYXNlO1xuICBjb25zdCBtYWpvciA9IG9wdGlvbnMubWFqb3JWZXJzaW9uO1xuICBjb25zdCBtaW5vciA9IG9wdGlvbnMubWlub3JWZXJzaW9uO1xuICBjb25zdCBtaW5NYWpvclZlcnNpb24gPSBvcHRpb25zLm1pbk1ham9yVmVyc2lvbjtcbiAgY29uc3QgcHJlZml4ID0gb3B0aW9ucy50YWdQcmVmaXggPz8gXCJcIjtcbiAgY29uc3QgYnVtcEZpbGUgPSBqb2luKGN3ZCwgb3B0aW9ucy5idW1wRmlsZSk7XG4gIGNvbnN0IGNoYW5nZWxvZ0ZpbGUgPSBqb2luKGN3ZCwgb3B0aW9ucy5jaGFuZ2Vsb2cpO1xuICBjb25zdCByZWxlYXNlVGFnRmlsZSA9IGpvaW4oY3dkLCBvcHRpb25zLnJlbGVhc2VUYWdGaWxlKTtcbiAgY29uc3QgYnVtcFBhY2thZ2UgPSBvcHRpb25zLmJ1bXBQYWNrYWdlID8/IFwiY29tbWl0LWFuZC10YWctdmVyc2lvbkBeMTJcIjtcblxuICBpZiAobWFqb3IgJiYgbWluTWFqb3JWZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYG1pbk1ham9yVmVyc2lvbiBhbmQgbWFqb3JWZXJzaW9uIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLmBcbiAgICApO1xuICB9XG4gIGlmIChtaW5vciAmJiAhbWFqb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG1pbm9yVmVyc2lvbiBhbmQgbWFqb3JWZXJzaW9uIG11c3QgYmUgdXNlZCB0b2dldGhlci5gKTtcbiAgfVxuXG4gIGF3YWl0IGZzLm1rZGlyKGRpcm5hbWUoYnVtcEZpbGUpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgYXdhaXQgZnMubWtkaXIoZGlybmFtZShjaGFuZ2Vsb2dGaWxlKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIGF3YWl0IGZzLm1rZGlyKGRpcm5hbWUocmVsZWFzZVRhZ0ZpbGUpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICBjb25zdCB7IGxhdGVzdFZlcnNpb24sIGxhdGVzdFRhZywgaXNGaXJzdFJlbGVhc2UgfSA9IGRldGVybWluZUxhdGVzdFRhZyh7XG4gICAgY3dkLFxuICAgIG1ham9yLFxuICAgIG1pbm9yLFxuICAgIHByZXJlbGVhc2UsXG4gICAgcHJlZml4LFxuICB9KTtcblxuICBjb25zdCB7IGNvbnRlbnRzLCBuZXdsaW5lIH0gPSBhd2FpdCB0cnlSZWFkVmVyc2lvbkZpbGUodmVyc2lvbkZpbGUpO1xuXG4gIC8vIHVwZGF0ZSB2ZXJzaW9uXG4gIGNvbnRlbnRzLnZlcnNpb24gPSBsYXRlc3RWZXJzaW9uO1xuXG4gIGxvZ2dpbmcuaW5mbyhcbiAgICBgVXBkYXRlICR7dmVyc2lvbkZpbGV9IHRvIGxhdGVzdCByZXNvbHZlZCB2ZXJzaW9uOiAke2xhdGVzdFZlcnNpb259YFxuICApO1xuICBhd2FpdCBmcy53cml0ZUZpbGUoXG4gICAgdmVyc2lvbkZpbGUsXG4gICAgSlNPTi5zdHJpbmdpZnkoY29udGVudHMsIHVuZGVmaW5lZCwgMikgKyAobmV3bGluZSA/IFwiXFxuXCIgOiBcIlwiKVxuICApO1xuXG4gIC8vIGNoZWNrIGZvciBjb21taXRzIHNpbmNlIHRoZSBsYXN0IHJlbGVhc2UgdGFnXG4gIGxldCBza2lwQnVtcCA9IGZhbHNlO1xuXG4gIC8vIEZpcnN0IFJlbGVhc2UgaXMgbmV2ZXIgc2tpcHBpbmcgYnVtcFxuICBpZiAoIWlzRmlyc3RSZWxlYXNlKSB7XG4gICAgY29uc3QgZmluZENvbW1pdHMgPSAoXG4gICAgICBvcHRpb25zLnJlbGVhc2FibGVDb21taXRzID8/IFJlbGVhc2FibGVDb21taXRzLmV2ZXJ5Q29tbWl0KCkuY21kXG4gICAgKS5yZXBsYWNlKFwiJExBVEVTVF9UQUdcIiwgbGF0ZXN0VGFnKTtcbiAgICBjb25zdCBjb21taXRzU2luY2VMYXN0VGFnID0gZXhlY09yVW5kZWZpbmVkKGZpbmRDb21taXRzLCB7IGN3ZCB9KT8uc3BsaXQoXG4gICAgICBcIlxcblwiXG4gICAgKTtcbiAgICBjb25zdCBudW1Db21taXRzU2luY2VMYXN0VGFnID0gY29tbWl0c1NpbmNlTGFzdFRhZz8ubGVuZ3RoID8/IDA7XG4gICAgbG9nZ2luZy5pbmZvKFxuICAgICAgYE51bWJlciBvZiBjb21taXRzIHNpbmNlICR7bGF0ZXN0VGFnfTogJHtudW1Db21taXRzU2luY2VMYXN0VGFnfWBcbiAgICApO1xuXG4gICAgLy8gTm90aGluZyB0byByZWxlYXNlIHJpZ2h0IG5vd1xuICAgIGlmIChudW1Db21taXRzU2luY2VMYXN0VGFnID09PSAwKSB7XG4gICAgICBsb2dnaW5nLmluZm8oXCJTa2lwcGluZyBidW1wLi4uXCIpO1xuICAgICAgc2tpcEJ1bXAgPSB0cnVlO1xuXG4gICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHRhZyAobG9jYWxseSlcbiAgICAgIC8vIGlmIHdlIGRvbid0IGRvIHRoaXMsIGNvbW1pdC1hbmQtdGFnLXZlcnNpb24gZ2VuZXJhdGVzIGFuIGVtcHR5IGNoYW5nZWxvZ1xuICAgICAgZXhlYyhgZ2l0IHRhZyAtLWRlbGV0ZSAke2xhdGVzdFRhZ31gLCB7IGN3ZCB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgYSBjb21taXQtYW5kLXRhZy12ZXJzaW9uIGNvbmZpZ3VyYXRpb24gZmlsZVxuICBjb25zdCByY2ZpbGUgPSBqb2luKGN3ZCwgXCIudmVyc2lvbnJjLmpzb25cIik7XG4gIGF3YWl0IGdlbmVyYXRlVmVyc2lvbnJjRmlsZShcbiAgICByY2ZpbGUsXG4gICAgdmVyc2lvbkZpbGUsXG4gICAgY2hhbmdlbG9nRmlsZSxcbiAgICBza2lwQnVtcCxcbiAgICBwcmVyZWxlYXNlLFxuICAgIG9wdGlvbnMudmVyc2lvbnJjT3B0aW9uc1xuICApO1xuXG4gIGNvbnN0IGNtZCA9IFtcIm5weFwiLCBidW1wUGFja2FnZV07XG4gIGlmIChpc0ZpcnN0UmVsZWFzZSAmJiAhbWluTWFqb3JWZXJzaW9uKSB7XG4gICAgY21kLnB1c2goXCItLWZpcnN0LXJlbGVhc2VcIik7XG4gIH1cbiAgaWYgKHByZWZpeCkge1xuICAgIGNtZC5wdXNoKGAtLXRhZy1wcmVmaXggJHtwcmVmaXh9dmApO1xuICB9XG4gIGlmIChtaW5NYWpvclZlcnNpb24pIHtcbiAgICBjb25zdCBbbWFqb3JWZXJzaW9uXSA9IGxhdGVzdFZlcnNpb24uc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IG1ham9yVmVyc2lvbk51bWJlciA9IHBhcnNlSW50KG1ham9yVmVyc2lvbiwgMTApO1xuICAgIGlmIChtYWpvclZlcnNpb25OdW1iZXIgPCBtaW5NYWpvclZlcnNpb24pIHtcbiAgICAgIGNtZC5wdXNoKGAtLXJlbGVhc2UtYXMgJHttaW5NYWpvclZlcnNpb259LjAuMGApO1xuICAgIH1cbiAgfVxuXG4gIGV4ZWMoY21kLmpvaW4oXCIgXCIpLCB7IGN3ZCB9KTtcblxuICAvLyBhZGQgdGhlIHRhZyBiYWNrIGlmIGl0IHdhcyBwcmV2aW91c2x5IHJlbW92ZWRcbiAgaWYgKHNraXBCdW1wKSB7XG4gICAgZXhlYyhgZ2l0IHRhZyAke2xhdGVzdFRhZ31gLCB7IGN3ZCB9KTtcbiAgfVxuXG4gIGF3YWl0IGZzLnJtKHJjZmlsZSwgeyBmb3JjZTogdHJ1ZSwgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gIGNvbnN0IG5ld1ZlcnNpb24gPSAoYXdhaXQgdHJ5UmVhZFZlcnNpb25GaWxlKHZlcnNpb25GaWxlKSkudmVyc2lvbjtcbiAgaWYgKCFuZXdWZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBidW1wIGZhaWxlZDogJHt2ZXJzaW9uRmlsZX0gZG9lcyBub3QgaGF2ZSBhIHZlcnNpb24gc2V0YCk7XG4gIH1cblxuICAvLyBpZiBNQUpPUiBpcyBkZWZpbmVkLCBlbnN1cmUgdGhhdCB0aGUgbmV3IHZlcnNpb24gaXMgd2l0aGluIHRoZSBzYW1lIG1ham9yIHZlcnNpb25cbiAgaWYgKG1ham9yKSB7XG4gICAgaWYgKCFuZXdWZXJzaW9uLnN0YXJ0c1dpdGgoYCR7bWFqb3J9LmApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBidW1wIGZhaWxlZDogdGhpcyBicmFuY2ggaXMgY29uZmlndXJlZCB0byBvbmx5IHB1Ymxpc2ggdiR7bWFqb3J9IHJlbGVhc2VzIC0gYnVtcCByZXN1bHRlZCBpbiAke25ld1ZlcnNpb259YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pbm9yKSB7XG4gICAgaWYgKCFuZXdWZXJzaW9uLnN0YXJ0c1dpdGgoYCR7bWFqb3J9LiR7bWlub3J9YCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGJ1bXAgZmFpbGVkOiB0aGlzIGJyYW5jaCBpcyBjb25maWd1cmVkIHRvIG9ubHkgcHVibGlzaCB2JHttYWpvcn0uJHttaW5vcn0gcmVsZWFzZXMgLSBidW1wIHJlc3VsdGVkIGluICR7bmV3VmVyc2lvbn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGF3YWl0IGZzLndyaXRlRmlsZShidW1wRmlsZSwgbmV3VmVyc2lvbik7XG5cbiAgY29uc3QgbmV3VGFnID0gYCR7cHJlZml4fXYke25ld1ZlcnNpb259YDtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHJlbGVhc2VUYWdGaWxlLCBuZXdUYWcpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cnlSZWFkVmVyc2lvbkZpbGUoXG4gIHZlcnNpb25GaWxlOiBzdHJpbmdcbik6IFByb21pc2U8eyBjb250ZW50czogYW55OyB2ZXJzaW9uPzogc3RyaW5nOyBuZXdsaW5lOiBib29sZWFuIH0+IHtcbiAgaWYgKCFleGlzdHNTeW5jKHZlcnNpb25GaWxlKSkge1xuICAgIHJldHVybiB7IGNvbnRlbnRzOiB7fSwgbmV3bGluZTogdHJ1ZSB9O1xuICB9XG4gIGNvbnN0IHJhdyA9IGF3YWl0IGZzLnJlYWRGaWxlKHZlcnNpb25GaWxlLCBcInV0Zi04XCIpO1xuICBjb25zdCBjb250ZW50cyA9IEpTT04ucGFyc2UocmF3KTtcblxuICByZXR1cm4ge1xuICAgIGNvbnRlbnRzLFxuICAgIHZlcnNpb246IGNvbnRlbnRzLnZlcnNpb24sXG4gICAgbmV3bGluZTogcmF3LmVuZHNXaXRoKFwiXFxuXCIpLFxuICB9O1xufVxuXG5pbnRlcmZhY2UgTGF0ZXN0VGFnT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXb3JraW5nIGRpcmVjdG9yeSBvZiB0aGUgZ2l0IHJlcG9zaXRvcnkuXG4gICAqL1xuICByZWFkb25seSBjd2Q6IHN0cmluZztcbiAgLyoqXG4gICAqIE1ham9yIHZlcnNpb24gdG8gc2VsZWN0IGZyb20uXG4gICAqL1xuICByZWFkb25seSBtYWpvcj86IG51bWJlcjtcbiAgLyoqXG4gICAqIE1pbm9yIHZlcnNpb24gdG8gc2VsZWN0IGZyb20uXG4gICAqL1xuICByZWFkb25seSBtaW5vcj86IG51bWJlcjtcbiAgLyoqXG4gICAqIEEgcHJlLXJlbGVhc2Ugc3VmZml4LlxuICAgKi9cbiAgcmVhZG9ubHkgcHJlcmVsZWFzZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEEgcHJlZml4IGFwcGxpZWQgdG8gYWxsIHRhZ3MuXG4gICAqL1xuICByZWFkb25seSBwcmVmaXg6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVWZXJzaW9ucmNGaWxlKFxuICByY2ZpbGU6IHN0cmluZyxcbiAgdmVyc2lvbkZpbGU6IHN0cmluZyxcbiAgY2hhbmdlbG9nRmlsZTogc3RyaW5nLFxuICBza2lwQnVtcDogYm9vbGVhbixcbiAgcHJlcmVsZWFzZT86IHN0cmluZyxcbiAgY29uZmlnT3B0aW9ucz86IENvbmZpZ1xuKSB7XG4gIHJldHVybiBmcy53cml0ZUZpbGUoXG4gICAgcmNmaWxlLFxuICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAge1xuICAgICAgICAuLi57XG4gICAgICAgICAgcGFja2FnZUZpbGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZpbGVuYW1lOiB2ZXJzaW9uRmlsZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgYnVtcEZpbGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZpbGVuYW1lOiB2ZXJzaW9uRmlsZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29tbWl0QWxsOiBmYWxzZSxcbiAgICAgICAgICBpbmZpbGU6IGNoYW5nZWxvZ0ZpbGUsXG4gICAgICAgICAgcHJlcmVsZWFzZTogcHJlcmVsZWFzZSxcbiAgICAgICAgICBoZWFkZXI6IFwiXCIsXG4gICAgICAgICAgc2tpcDoge1xuICAgICAgICAgICAgY29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgdGFnOiB0cnVlLFxuICAgICAgICAgICAgYnVtcDogc2tpcEJ1bXAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5jb25maWdPcHRpb25zLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIDJcbiAgICApXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbGF0ZXN0IHJlbGVhc2UgdGFnLlxuICogQHBhcmFtIG1ham9yIChvcHRpb25hbCkgQSBtYWpvciB2ZXJzaW9uIGxpbmUgdG8gc2VsZWN0IGZyb21cbiAqIEBwYXJhbSBwcmVyZWxlYXNlIChvcHRpb25hbCkgQSBwcmUtcmVsZWFzZSBzdWZmaXguXG4gKiBAcmV0dXJucyB0aGUgbGF0ZXN0IHRhZywgYW5kIHdoZXRoZXIgaXQgaXMgdGhlIGZpcnN0IHJlbGVhc2Ugb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUxhdGVzdFRhZyhvcHRpb25zOiBMYXRlc3RUYWdPcHRpb25zKToge1xuICBsYXRlc3RWZXJzaW9uOiBzdHJpbmc7XG4gIGxhdGVzdFRhZzogc3RyaW5nO1xuICBpc0ZpcnN0UmVsZWFzZTogYm9vbGVhbjtcbn0ge1xuICBjb25zdCB7IGN3ZCwgbWFqb3IsIG1pbm9yLCBwcmVyZWxlYXNlLCBwcmVmaXggfSA9IG9wdGlvbnM7XG5cbiAgLy8gZmlsdGVyIG9ubHkgdGFncyBmb3IgdGhpcyBwcmVmaXggYW5kIG1ham9yIHZlcnNpb24gaWYgc3BlY2lmaWVkIChzdGFydCB3aXRoIFwidk5OLlwiKS5cbiAgbGV0IHByZWZpeEZpbHRlcjogc3RyaW5nO1xuICBpZiAobWFqb3IgIT09IHVuZGVmaW5lZCAmJiBtaW5vciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJlZml4RmlsdGVyID0gYCR7cHJlZml4fXYke21ham9yfS4ke21pbm9yfS4qYDtcbiAgfSBlbHNlIGlmIChtYWpvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJlZml4RmlsdGVyID0gYCR7cHJlZml4fXYke21ham9yfS4qYDtcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhGaWx0ZXIgPSBgJHtwcmVmaXh9dipgO1xuICB9XG5cbiAgY29uc3QgbGlzdEdpdFRhZ3MgPSBbXG4gICAgXCJnaXRcIixcbiAgICAnLWMgXCJ2ZXJzaW9uc29ydC5zdWZmaXg9LVwiJywgLy8gbWFrZXMgc3VyZSBwcmUtcmVsZWFzZSB2ZXJzaW9ucyBhcmUgbGlzdGVkIGFmdGVyIHRoZSBwcmltYXJ5IHZlcnNpb25cbiAgICBcInRhZ1wiLFxuICAgICctLXNvcnQ9XCItdmVyc2lvbjpyZWZuYW1lXCInLCAvLyBzb3J0IGFzIHZlcnNpb25zIGFuZCBub3QgbGV4aWNvZ3JhcGhpY2FsbHlcbiAgICBcIi0tbGlzdFwiLFxuICAgIGBcIiR7cHJlZml4RmlsdGVyfVwiYCxcbiAgXS5qb2luKFwiIFwiKTtcblxuICBjb25zdCBzdGRvdXQgPSBleGVjQ2FwdHVyZShsaXN0R2l0VGFncywgeyBjd2QgfSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuXG4gIGxldCB0YWdzID0gc3Rkb3V0Py5zcGxpdChcIlxcblwiKTtcblxuICAvLyBpZiBwcmVyZWxlYXNlIGlzIHNldCBhbmQgdGhlcmUgYXJlIGV4aXN0aW5nIHByZXJlbGVhc2UgdGFncywgZmlsdGVyIHZlcnNpb25zIHRoYXQgZW5kIHdpdGggXCItUFJFLmRkZFwiLlxuICBjb25zdCBwcmVyZWxlYXNlVGFncyA9IHRhZ3MuZmlsdGVyKCh4KSA9PlxuICAgIG5ldyBSZWdFeHAoYC0ke3ByZXJlbGVhc2V9XFwuWzAtOV0rJGApLnRlc3QoeClcbiAgKTtcbiAgaWYgKHByZXJlbGVhc2UgJiYgcHJlcmVsZWFzZVRhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8qKlxuICAgICAqIENvdmVyIHRoZSBmb2xsb3dpbmcgY2FzZSBzcGVjaWZpY2FsbHlcbiAgICAgKiAxIC0gdjEuMC4wXG4gICAgICogMiAtIHYxLjAuMS1iZXRhLjBcbiAgICAgKiAzIC0gdjEuMC4xLWJldGEuMVxuICAgICAqIDQgLSB2MS4wLjFcbiAgICAgKiA1IC0gbm93IHB1Ymxpc2ggYSBuZXcgcmVsZWFzZSBvbiB0aGUgcHJlcmVsZWFzZSBicmFuY2hcbiAgICAgKiAgICBieSBzZXR0aW5nIHRoZSBsYXRlc3RUYWcgYXMgdjEuMC4xIGluc3RlYWQgb2YgdjEuMC4xLWJldGEuMVxuICAgICAqL1xuICAgIGNvbnN0IHJlbGVhc2VUYWdzID0gdGFncy5maWx0ZXIoKHgpID0+XG4gICAgICBuZXcgUmVnRXhwKGBedihbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKSRgKS50ZXN0KHgpXG4gICAgKTtcbiAgICBpZiAoXG4gICAgICByZWxlYXNlVGFncy5sZW5ndGggPiAwICYmXG4gICAgICBjb21wYXJlKHJlbGVhc2VUYWdzWzBdLCBwcmVyZWxlYXNlVGFnc1swXSkgPT09IDFcbiAgICApIHtcbiAgICAgIHRhZ3MgPSByZWxlYXNlVGFncztcbiAgICB9IGVsc2Uge1xuICAgICAgdGFncyA9IHByZXJlbGVhc2VUYWdzO1xuICAgIH1cbiAgfVxuXG4gIHRhZ3MgPSB0YWdzLmZpbHRlcigoeCkgPT4geCk7XG5cbiAgLy8gaWYgYSBwcmUtcmVsZWFzZSB0YWcgaXMgdXNlZCwgdGhlbiBhZGQgaXQgdG8gdGhlIGluaXRpYWwgdmVyc2lvblxuICBsZXQgaXNGaXJzdFJlbGVhc2UgPSBmYWxzZTtcbiAgbGV0IGxhdGVzdFRhZztcblxuICBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgbGF0ZXN0VGFnID0gdGFnc1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbml0aWFsID0gYCR7cHJlZml4fXYke21ham9yID8/IDB9LiR7bWlub3IgPz8gMH0uMGA7XG4gICAgbGF0ZXN0VGFnID0gcHJlcmVsZWFzZSA/IGAke2luaXRpYWx9LSR7cHJlcmVsZWFzZX0uMGAgOiBpbml0aWFsO1xuICAgIGlzRmlyc3RSZWxlYXNlID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHJlbW92ZSB0YWcgcHJlZml4IChpZiBleGlzdHMpXG4gIGxldCBsYXRlc3RWZXJzaW9uID0gbGF0ZXN0VGFnO1xuICBpZiAocHJlZml4ICYmIGxhdGVzdFZlcnNpb24uc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgbGF0ZXN0VmVyc2lvbiA9IGxhdGVzdFZlcnNpb24uc3Vic3RyKHByZWZpeC5sZW5ndGgpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIFwidlwiIHByZWZpeCAoaWYgZXhpc3RzKVxuICBpZiAobGF0ZXN0VmVyc2lvbi5zdGFydHNXaXRoKFwidlwiKSkge1xuICAgIGxhdGVzdFZlcnNpb24gPSBsYXRlc3RWZXJzaW9uLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIHJldHVybiB7IGxhdGVzdFZlcnNpb24sIGxhdGVzdFRhZywgaXNGaXJzdFJlbGVhc2UgfTtcbn1cbiJdfQ==