"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmAccess = exports.NodePackageManager = exports.NodePackage = exports.CodeArtifactAuthProvider = void 0;
exports.defaultNpmToken = defaultNpmToken;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fs_1 = require("fs");
const path_1 = require("path");
const semver = require("semver");
const util_1 = require("./util");
const yarnrc_1 = require("./yarnrc");
const _resolve_1 = require("../_resolve");
const component_1 = require("../component");
const dependencies_1 = require("../dependencies");
const json_1 = require("../json");
const release_1 = require("../release");
const task_runtime_1 = require("../task-runtime");
const util_2 = require("../util");
const UNLICENSED = "UNLICENSED";
const DEFAULT_NPM_REGISTRY_URL = "https://registry.npmjs.org/";
const GITHUB_PACKAGES_REGISTRY = "npm.pkg.github.com";
const DEFAULT_NPM_TOKEN_SECRET = "NPM_TOKEN";
const DEFAULT_GITHUB_TOKEN_SECRET = "GITHUB_TOKEN";
/**
 * Options for authorizing requests to a AWS CodeArtifact npm repository.
 */
var CodeArtifactAuthProvider;
(function (CodeArtifactAuthProvider) {
    /**
     * Fixed credentials provided via Github secrets.
     */
    CodeArtifactAuthProvider["ACCESS_AND_SECRET_KEY_PAIR"] = "ACCESS_AND_SECRET_KEY_PAIR";
    /**
     * Ephemeral credentials provided via Github's OIDC integration with an IAM role.
     * See:
     * https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html
     * https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services
     */
    CodeArtifactAuthProvider["GITHUB_OIDC"] = "GITHUB_OIDC";
})(CodeArtifactAuthProvider || (exports.CodeArtifactAuthProvider = CodeArtifactAuthProvider = {}));
/**
 * Represents the npm `package.json` file.
 */
class NodePackage extends component_1.Component {
    /**
     * Returns the `NodePackage` instance associated with a project or `undefined` if
     * there is no NodePackage.
     * @param project The project
     * @returns A NodePackage, or undefined
     */
    static of(project) {
        const isIt = (o) => o instanceof NodePackage;
        return project.components.find(isIt);
    }
    constructor(project, options = {}) {
        super(project);
        this.scripts = {};
        this.scriptsToBeRemoved = new Set();
        this.keywords = new Set();
        this.bin = {};
        this.engines = {};
        this.packageName = options.packageName ?? project.name;
        this.peerDependencyOptions = {
            pinnedDevDependency: true,
            ...options.peerDependencyOptions,
        };
        this.allowLibraryDependencies = options.allowLibraryDependencies ?? true;
        this.packageManager =
            options.packageManager ?? NodePackageManager.YARN_CLASSIC;
        this.entrypoint = options.entrypoint ?? "lib/index.js";
        this.lockFile = determineLockfile(this.packageManager);
        this.project.annotateGenerated(`/${this.lockFile}`);
        const { npmAccess, npmRegistry, npmRegistryUrl, npmTokenSecret, codeArtifactOptions, scopedPackagesOptions, npmProvenance, } = this.parseNpmOptions(options);
        this.npmAccess = npmAccess;
        this.npmRegistry = npmRegistry;
        this.npmRegistryUrl = npmRegistryUrl;
        this.npmTokenSecret = npmTokenSecret;
        this.codeArtifactOptions = codeArtifactOptions;
        this.scopedPackagesOptions = scopedPackagesOptions;
        this.npmProvenance = npmProvenance;
        this.processDeps(options);
        this._prev = this.readPackageJson();
        // empty objects are here to preserve order for backwards compatibility
        this.manifest = {
            name: this.packageName,
            description: options.description,
            repository: !options.repository
                ? undefined
                : {
                    type: "git",
                    url: options.repository,
                    directory: options.repositoryDirectory,
                },
            bin: () => this.renderBin(),
            scripts: () => this.renderScripts(),
            author: this.renderAuthor(options),
            devDependencies: {},
            peerDependencies: {},
            dependencies: {},
            bundledDependencies: [],
            ...this.renderPackageResolutions(),
            keywords: () => this.renderKeywords(),
            engines: () => this.renderEngines(),
            main: this.entrypoint !== "" ? this.entrypoint : undefined,
            license: () => this.license ?? UNLICENSED,
            homepage: options.homepage,
            publishConfig: () => this.renderPublishConfig(),
            typesVersions: this._prev?.typesVersions,
            // in release CI builds we bump the version before we run "build" so we want
            // to preserve the version number. otherwise, we always set it to 0.0.0
            version: this.determineVersion(this._prev?.version),
            bugs: options.bugsEmail || options.bugsUrl
                ? {
                    email: options.bugsEmail,
                    url: options.bugsUrl,
                }
                : undefined,
        };
        // Configure Yarn Berry if using
        if (this.packageManager === NodePackageManager.YARN_BERRY ||
            this.packageManager === NodePackageManager.YARN2) {
            this.configureYarnBerry(project, options);
        }
        // add tasks for scripts from options (if specified)
        // @deprecated
        for (const [cmdname, shell] of Object.entries(options.scripts ?? {})) {
            project.addTask(cmdname, { exec: shell });
        }
        this.file = new json_1.JsonFile(this, "package.json", {
            obj: this.manifest,
            readonly: false, // we want "yarn add" to work and we have anti-tamper
            newline: true, // all package managers prefer a newline, see https://github.com/projen/projen/issues/2076
            committed: true, // needs to be committed so users can install the dependencies
        });
        this.addKeywords(...(options.keywords ?? []));
        this.addBin(options.bin ?? {});
        // automatically add all executable files under "bin"
        if (options.autoDetectBin ?? true) {
            this.autoDiscoverBinaries();
        }
        // node version
        this.minNodeVersion = options.minNodeVersion;
        this.maxNodeVersion = options.maxNodeVersion;
        this.pnpmVersion = options.pnpmVersion ?? "7";
        this.addNodeEngine();
        this.addCodeArtifactLoginScript();
        // license
        if (options.licensed ?? true) {
            this.license = options.license ?? "Apache-2.0";
        }
        this.installTask = project.addTask("install", {
            description: "Install project dependencies and update lockfile (non-frozen)",
            exec: this.installAndUpdateLockfileCommand,
        });
        this.installCiTask = project.addTask("install:ci", {
            description: "Install project dependencies using frozen lockfile",
            exec: this.installCommand,
        });
    }
    /**
     * Defines normal dependencies.
     *
     * @param deps Names modules to install. By default, the the dependency will
     * be installed in the next `npx projen` run and the version will be recorded
     * in your `package.json` file. You can upgrade manually or using `yarn
     * add/upgrade`. If you wish to specify a version range use this syntax:
     * `module@^7`.
     */
    addDeps(...deps) {
        for (const dep of deps) {
            this.project.deps.addDependency(dep, dependencies_1.DependencyType.RUNTIME);
        }
    }
    /**
     * Defines development/test dependencies.
     *
     * @param deps Names modules to install. By default, the the dependency will
     * be installed in the next `npx projen` run and the version will be recorded
     * in your `package.json` file. You can upgrade manually or using `yarn
     * add/upgrade`. If you wish to specify a version range use this syntax:
     * `module@^7`.
     */
    addDevDeps(...deps) {
        for (const dep of deps) {
            this.project.deps.addDependency(dep, dependencies_1.DependencyType.BUILD);
        }
    }
    /**
     * Defines peer dependencies.
     *
     * When adding peer dependencies, a devDependency will also be added on the
     * pinned version of the declared peer. This will ensure that you are testing
     * your code against the minimum version required from your consumers.
     *
     * @param deps Names modules to install. By default, the the dependency will
     * be installed in the next `npx projen` run and the version will be recorded
     * in your `package.json` file. You can upgrade manually or using `yarn
     * add/upgrade`. If you wish to specify a version range use this syntax:
     * `module@^7`.
     */
    addPeerDeps(...deps) {
        if (Object.keys(deps).length && !this.allowLibraryDependencies) {
            throw new Error(`cannot add peer dependencies to an APP project: ${Object.keys(deps).join(",")}`);
        }
        for (const dep of deps) {
            this.project.deps.addDependency(dep, dependencies_1.DependencyType.PEER);
        }
    }
    /**
     * Defines bundled dependencies.
     *
     * Bundled dependencies will be added as normal dependencies as well as to the
     * `bundledDependencies` section of your `package.json`.
     *
     * @param deps Names modules to install. By default, the the dependency will
     * be installed in the next `npx projen` run and the version will be recorded
     * in your `package.json` file. You can upgrade manually or using `yarn
     * add/upgrade`. If you wish to specify a version range use this syntax:
     * `module@^7`.
     */
    addBundledDeps(...deps) {
        if (deps.length && !this.allowLibraryDependencies) {
            throw new Error(`cannot add bundled dependencies to an APP project: ${deps.join(",")}`);
        }
        for (const dep of deps) {
            this.project.deps.addDependency(dep, dependencies_1.DependencyType.BUNDLED);
        }
    }
    /**
     * Adds an `engines` requirement to your package.
     * @param engine The engine (e.g. `node`)
     * @param version The semantic version requirement (e.g. `^10`)
     */
    addEngine(engine, version) {
        this.engines[engine] = version;
    }
    /**
     * Adds keywords to package.json (deduplicated)
     * @param keywords The keywords to add
     */
    addKeywords(...keywords) {
        for (const k of keywords) {
            this.keywords.add(k);
        }
    }
    addBin(bins) {
        for (const [k, v] of Object.entries(bins)) {
            this.bin[k] = v;
        }
    }
    /**
     * Add a npm package.json script.
     *
     * @param name The script name
     * @param command The command to execute
     */
    setScript(name, command) {
        this.scripts[name] = command;
    }
    /**
     * Removes an npm script (always successful).
     *
     * @param name The name of the script.
     */
    removeScript(name) {
        // need to keep track in case there's a task of the same name
        this.scriptsToBeRemoved.add(name);
        delete this.scripts[name];
    }
    /**
     * Indicates if a script by the given name is defined.
     * @param name The name of the script
     * @deprecated Use `project.tasks.tryFind(name)`
     */
    hasScript(name) {
        return this.project.tasks.tryFind(name) !== undefined;
    }
    /**
     * Directly set fields in `package.json`.
     * @escape
     * @param name field name
     * @param value field value
     */
    addField(name, value) {
        this.manifest[name] = value;
    }
    /**
     * Sets the package version.
     * @param version Package version.
     */
    addVersion(version) {
        this.manifest.version = version;
    }
    /**
     * Defines resolutions for dependencies to change the normally resolved
     * version of a dependency to something else.
     *
     * @param resolutions Names resolutions to be added. Specify a version or
     * range with this syntax:
     * `module@^7`
     */
    addPackageResolutions(...resolutions) {
        for (const resolution of resolutions) {
            this.project.deps.addDependency(resolution, dependencies_1.DependencyType.OVERRIDE);
        }
    }
    /**
     * Returns the command to execute in order to install all dependencies (always frozen).
     */
    get installCommand() {
        return this.renderInstallCommand(true);
    }
    /**
     * Renders `yarn install` or `npm install` with lockfile update (not frozen)
     */
    get installAndUpdateLockfileCommand() {
        return this.renderInstallCommand(false);
    }
    /**
     * Attempt to resolve the currently installed version for a given dependency.
     *
     * @remarks
     * This method will first look through the current project's dependencies.
     * If found and semantically valid (not '*'), that will be used.
     * Otherwise, it will fall back to locating a `package.json` manifest for the dependency
     * through node's internal resolution reading the version from there.
     *
     * @param dependencyName Dependency to resolve for.
     */
    tryResolveDependencyVersion(dependencyName) {
        try {
            const fromDeps = this.project.deps.tryGetDependency(dependencyName);
            const version = semver.coerce(fromDeps?.version, { loose: true });
            if (version) {
                return version.format();
            }
        }
        catch { }
        return (0, util_1.tryResolveDependencyVersion)(dependencyName, {
            paths: [this.project.outdir],
        });
    }
    // ---------------------------------------------------------------------------------------
    synthesize() {
        this._renderedDeps = this.renderDependencies();
        super.synthesize();
    }
    postSynthesize() {
        super.postSynthesize();
        // only run "install" if package.json has changed or if we don't have a
        // `node_modules` directory.
        if (this.file.changed ||
            !(0, fs_1.existsSync)((0, path_1.join)(this.project.outdir, "node_modules"))) {
            this.installDependencies();
        }
        // resolve "*" deps in package.json and update it. if it was changed,
        // install deps again so that lockfile is updated.
        if (this.resolveDepsAndWritePackageJson()) {
            this.installDependencies();
        }
    }
    /**
     * The command which executes "projen".
     * @deprecated use `project.projenCommand` instead.
     */
    get projenCommand() {
        return this.project.projenCommand;
    }
    /**
     * Returns `true` if we are running within a CI build.
     */
    get isAutomatedBuild() {
        return (0, util_2.isTruthy)(process.env.CI);
    }
    determineVersion(currVersion) {
        if (!this.isReleaseBuild) {
            return "0.0.0";
        }
        return currVersion ?? "0.0.0";
    }
    /**
     * Returns `true` if this is a CI release build.
     */
    get isReleaseBuild() {
        return (0, util_2.isTruthy)(process.env.RELEASE);
    }
    // -------------------------------------------------------------------------------------------
    parseNpmOptions(options) {
        let npmRegistryUrl = options.npmRegistryUrl;
        if (options.npmRegistry) {
            if (npmRegistryUrl) {
                throw new Error('cannot use the deprecated "npmRegistry" together with "npmRegistryUrl". please use "npmRegistryUrl" instead.');
            }
            npmRegistryUrl = `https://${options.npmRegistry}`;
        }
        const npmr = new URL(npmRegistryUrl ?? DEFAULT_NPM_REGISTRY_URL);
        if (!npmr || !npmr.hostname || !npmr.href) {
            throw new Error(`unable to determine npm registry host from url ${npmRegistryUrl}. Is this really a URL?`);
        }
        const npmAccess = options.npmAccess ?? defaultNpmAccess(this.packageName);
        if (!isScoped(this.packageName) && npmAccess === NpmAccess.RESTRICTED) {
            throw new Error(`"npmAccess" cannot be RESTRICTED for non-scoped npm package "${this.packageName}"`);
        }
        const npmProvenance = options.npmProvenance ?? npmAccess === NpmAccess.PUBLIC;
        if (npmProvenance && npmAccess !== NpmAccess.PUBLIC) {
            throw new Error(`"npmProvenance" can only be enabled for public packages`);
        }
        const isAwsCodeArtifact = (0, release_1.isAwsCodeArtifactRegistry)(npmRegistryUrl);
        const hasScopedPackage = options.scopedPackagesOptions &&
            options.scopedPackagesOptions.length !== 0;
        if (isAwsCodeArtifact) {
            if (options.npmTokenSecret) {
                throw new Error('"npmTokenSecret" must not be specified when publishing AWS CodeArtifact.');
            }
            else if (options.codeArtifactOptions?.authProvider ===
                CodeArtifactAuthProvider.GITHUB_OIDC) {
                if (options.codeArtifactOptions.accessKeyIdSecret ||
                    options.codeArtifactOptions.secretAccessKeySecret) {
                    throw new Error("access and secret key pair should not be provided when using GITHUB_OIDC auth provider for AWS CodeArtifact");
                }
                else if (!options.codeArtifactOptions.roleToAssume) {
                    throw new Error('"roleToAssume" property is required when using GITHUB_OIDC for AWS CodeArtifact options');
                }
            }
        }
        else {
            if ((options.codeArtifactOptions?.accessKeyIdSecret ||
                options.codeArtifactOptions?.secretAccessKeySecret ||
                options.codeArtifactOptions?.roleToAssume) &&
                !hasScopedPackage) {
                throw new Error("codeArtifactOptions must only be specified when publishing AWS CodeArtifact or used in scoped packages.");
            }
        }
        // apply defaults for AWS CodeArtifact
        let codeArtifactOptions;
        if (isAwsCodeArtifact || hasScopedPackage) {
            const authProvider = options.codeArtifactOptions?.authProvider ??
                CodeArtifactAuthProvider.ACCESS_AND_SECRET_KEY_PAIR;
            const isAccessSecretKeyPairAuth = authProvider === CodeArtifactAuthProvider.ACCESS_AND_SECRET_KEY_PAIR;
            codeArtifactOptions = {
                authProvider,
                accessKeyIdSecret: options.codeArtifactOptions?.accessKeyIdSecret ??
                    (isAccessSecretKeyPairAuth ? "AWS_ACCESS_KEY_ID" : undefined),
                secretAccessKeySecret: options.codeArtifactOptions?.secretAccessKeySecret ??
                    (isAccessSecretKeyPairAuth ? "AWS_SECRET_ACCESS_KEY" : undefined),
                roleToAssume: options.codeArtifactOptions?.roleToAssume,
            };
        }
        return {
            npmAccess,
            npmRegistry: npmr.hostname + this.renderNpmRegistryPath(npmr.pathname),
            npmRegistryUrl: npmr.href,
            npmTokenSecret: defaultNpmToken(options.npmTokenSecret, npmr.hostname),
            codeArtifactOptions,
            scopedPackagesOptions: this.parseScopedPackagesOptions(options.scopedPackagesOptions),
            npmProvenance,
        };
    }
    parseScopedPackagesOptions(scopedPackagesOptions) {
        if (!scopedPackagesOptions) {
            return undefined;
        }
        return scopedPackagesOptions.map((option) => {
            if (!isScoped(option.scope)) {
                throw new Error(`Scope must start with "@" in options, found ${option.scope}`);
            }
            if (!(0, release_1.isAwsCodeArtifactRegistry)(option.registryUrl)) {
                throw new Error(`Only AWS Code artifact scoped registry is supported for now, found ${option.registryUrl}`);
            }
            const result = {
                registryUrl: option.registryUrl,
                scope: option.scope,
            };
            return result;
        });
    }
    addCodeArtifactLoginScript() {
        if (!this.scopedPackagesOptions ||
            this.scopedPackagesOptions.length === 0) {
            return;
        }
        this.project.addTask("ca:login", {
            requiredEnv: ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"],
            steps: [
                { exec: "which aws" }, // check that AWS CLI is installed
                ...this.scopedPackagesOptions.map((scopedPackagesOption) => {
                    const { registryUrl, scope } = scopedPackagesOption;
                    const { domain, region, accountId, registry } = (0, util_1.extractCodeArtifactDetails)(registryUrl);
                    // reference: https://docs.aws.amazon.com/codeartifact/latest/ug/npm-auth.html
                    const commands = [
                        `npm config set ${scope}:registry ${registryUrl}`,
                        `CODEARTIFACT_AUTH_TOKEN=$(aws codeartifact get-authorization-token --domain ${domain} --region ${region} --domain-owner ${accountId} --query authorizationToken --output text)`,
                        `npm config set //${registry}:_authToken=$CODEARTIFACT_AUTH_TOKEN`,
                    ];
                    if (!this.minNodeVersion || semver.major(this.minNodeVersion) <= 16)
                        commands.push(`npm config set //${registry}:always-auth=true`);
                    return {
                        exec: commands.join("; "),
                    };
                }),
            ],
        });
    }
    addNodeEngine() {
        if (!this.minNodeVersion && !this.maxNodeVersion) {
            return;
        }
        let nodeVersion = "";
        if (this.minNodeVersion) {
            nodeVersion += `>= ${this.minNodeVersion}`;
        }
        if (this.maxNodeVersion) {
            nodeVersion += ` <= ${this.maxNodeVersion}`;
        }
        this.addEngine("node", nodeVersion);
    }
    renderNpmRegistryPath(path) {
        if (!path || path == "/") {
            return "";
        }
        else {
            return path;
        }
    }
    renderInstallCommand(frozen) {
        switch (this.packageManager) {
            case NodePackageManager.YARN:
            case NodePackageManager.YARN_CLASSIC:
                return [
                    "yarn install",
                    "--check-files", // ensure all modules exist (especially projen which was just removed).
                    ...(frozen ? ["--frozen-lockfile"] : []),
                ].join(" ");
            case NodePackageManager.YARN2:
            case NodePackageManager.YARN_BERRY:
                return ["yarn install", ...(frozen ? ["--immutable"] : [])].join(" ");
            case NodePackageManager.NPM:
                return frozen ? "npm ci" : "npm install";
            case NodePackageManager.PNPM:
                return frozen
                    ? "pnpm i --frozen-lockfile"
                    : "pnpm i --no-frozen-lockfile";
            case NodePackageManager.BUN:
                return ["bun install", ...(frozen ? ["--frozen-lockfile"] : [])].join(" ");
            default:
                throw new Error(`unexpected package manager ${this.packageManager}`);
        }
    }
    processDeps(options) {
        this.addDeps(...(options.deps ?? []));
        this.addDevDeps(...(options.devDeps ?? []));
        this.addPeerDeps(...(options.peerDeps ?? []));
        this.addBundledDeps(...(options.bundledDeps ?? []));
    }
    renderDependencies() {
        const devDependencies = {};
        const peerDependencies = {};
        const dependencies = {};
        const bundledDependencies = new Array();
        // synthetic dependencies: add a pinned build dependency to ensure we are
        // testing against the minimum requirement of the peer.
        if (this.peerDependencyOptions.pinnedDevDependency) {
            for (const dep of this.project.deps.all.filter((d) => d.type === dependencies_1.DependencyType.PEER)) {
                let req = dep.name;
                // Skip if we already have a runtime dependency on this peer and no build dependency yet.
                // If there is a build dep already, we need to override its version.
                if (this.project.deps.tryGetDependency(dep.name, dependencies_1.DependencyType.RUNTIME) &&
                    !this.project.deps.tryGetDependency(dep.name, dependencies_1.DependencyType.BUILD)) {
                    continue;
                }
                if (dep.version) {
                    const ver = (0, util_1.minVersion)(dep.version);
                    if (!ver) {
                        throw new Error(`unable to determine minimum semver for peer dependency ${dep.name}@${dep.version}`);
                    }
                    req += "@" + ver;
                }
                this.addDevDeps(req);
            }
        }
        for (const dep of this.project.deps.all) {
            let version = dep.version ?? "*";
            let name = dep.name;
            if (name.startsWith("file:")) {
                const localDependencyPath = name.substring(5);
                const depPackageJson = (0, path_1.resolve)(this.project.outdir, localDependencyPath, "package.json");
                const pkgFile = (0, fs_1.readFileSync)(depPackageJson, "utf8");
                const pkg = JSON.parse(pkgFile);
                version = localDependencyPath;
                name = pkg.name;
            }
            switch (dep.type) {
                case dependencies_1.DependencyType.BUNDLED:
                    bundledDependencies.push(name);
                    if (this.project.deps.all.find((d) => d.name === name && d.type === dependencies_1.DependencyType.PEER)) {
                        throw new Error(`unable to bundle "${name}". it cannot appear as a peer dependency`);
                    }
                    // also add as a runtime dependency
                    dependencies[name] = version;
                    break;
                case dependencies_1.DependencyType.PEER:
                    peerDependencies[name] = version;
                    break;
                case dependencies_1.DependencyType.RUNTIME:
                    dependencies[name] = version;
                    break;
                case dependencies_1.DependencyType.TEST:
                case dependencies_1.DependencyType.DEVENV:
                case dependencies_1.DependencyType.BUILD:
                    devDependencies[name] = version;
                    break;
            }
        }
        // returns a lazy value to normalize during synthesis
        const normalize = (obj) => () => (0, util_2.sorted)(obj);
        // update the manifest we are about to save into `package.json`
        this.manifest.devDependencies = normalize(devDependencies);
        this.manifest.peerDependencies = normalize(peerDependencies);
        this.manifest.dependencies = normalize(dependencies);
        this.manifest.bundledDependencies = (0, util_2.sorted)(bundledDependencies);
        // nothing further to do if package.json file does not exist
        if (!this._prev) {
            return { devDependencies, peerDependencies, dependencies };
        }
        const readDeps = (user, current = {}) => {
            for (const [name, userVersion] of Object.entries(user)) {
                const currentVersion = current[name];
                // respect user version if it's not '*' or if current version is undefined
                if (userVersion !== "*" || !currentVersion || currentVersion === "*") {
                    continue;
                }
                // memoize current version in memory so it is preserved when saving
                user[name] = currentVersion;
            }
            // report removals
            for (const name of Object.keys(current ?? {})) {
                if (!user[name]) {
                    this.project.logger.verbose(`${name}: removed`);
                }
            }
        };
        readDeps(devDependencies, this._prev.devDependencies);
        readDeps(dependencies, this._prev.dependencies);
        readDeps(peerDependencies, this._prev.peerDependencies);
        return { devDependencies, dependencies, peerDependencies };
    }
    /**
     * Resolves any deps that do not have a specified version (e.g. `*`) and
     * update `package.json` if needed.
     *
     * @returns `true` if package.json was updated or `false` if not.
     */
    resolveDepsAndWritePackageJson() {
        const outdir = this.project.outdir;
        const rootPackageJson = (0, path_1.join)(outdir, "package.json");
        const original = (0, fs_1.readFileSync)(rootPackageJson, "utf8");
        const pkg = JSON.parse(original);
        const resolveDeps = (current, user) => {
            const result = {};
            current = current ?? {};
            user = user ?? {};
            for (const [name, currentDefinition] of Object.entries(user)) {
                // find actual version from node_modules
                let desiredVersion = currentDefinition;
                if (currentDefinition === "*") {
                    // we already know we don't have the version in project `deps`,
                    // so skip straight to checking manifest.
                    const resolvedVersion = (0, util_1.tryResolveDependencyVersion)(name, {
                        paths: [this.project.outdir],
                    });
                    if (!resolvedVersion) {
                        this.project.logger.warn(`unable to resolve version for ${name} from installed modules`);
                        continue;
                    }
                    desiredVersion = `^${resolvedVersion}`;
                }
                if (currentDefinition !== desiredVersion) {
                    this.project.logger.verbose(`${name}: ${currentDefinition} => ${desiredVersion}`);
                }
                result[name] = desiredVersion;
            }
            // print removed packages
            for (const name of Object.keys(current)) {
                if (!result[name]) {
                    this.project.logger.verbose(`${name} removed`);
                }
            }
            return result;
        };
        const rendered = this._renderedDeps;
        if (!rendered) {
            throw new Error("assertion failed");
        }
        const deps = resolveDeps(pkg.dependencies, rendered.dependencies);
        const devDeps = resolveDeps(pkg.devDependencies, rendered.devDependencies);
        const peerDeps = resolveDeps(pkg.peerDependencies, rendered.peerDependencies);
        if (this.peerDependencyOptions.pinnedDevDependency) {
            for (const [name, version] of Object.entries(peerDeps)) {
                // Skip if we already have a runtime dependency on this peer
                // or if devDependency version is already set.
                // Relies on the "*" devDependency added in the presynth step
                if (deps[name] || rendered.devDependencies[name] !== "*") {
                    continue;
                }
                // Take version and pin as dev dependency
                const ver = (0, util_1.minVersion)(version);
                if (!ver) {
                    throw new Error(`unable to determine minimum semver for peer dependency ${name}@${version}`);
                }
                devDeps[name] = ver;
            }
        }
        pkg.dependencies = (0, util_2.sorted)(deps);
        pkg.devDependencies = (0, util_2.sorted)(devDeps);
        pkg.peerDependencies = (0, util_2.sorted)(peerDeps);
        const updated = JSON.stringify(pkg, undefined, 2) + "\n";
        if (original === updated) {
            return false;
        }
        (0, util_2.writeFile)(rootPackageJson, updated);
        return true;
    }
    renderPackageResolutions() {
        const render = () => {
            const overridingDependencies = this.project.deps.all.filter((dep) => dep.type === dependencies_1.DependencyType.OVERRIDE);
            if (!overridingDependencies.length) {
                return undefined;
            }
            return Object.fromEntries(overridingDependencies.map(({ name, version = "*" }) => [name, version]));
        };
        switch (this.packageManager) {
            case NodePackageManager.NPM:
                return { overrides: render };
            case NodePackageManager.PNPM:
                return this.project.parent
                    ? undefined
                    : { pnpm: { overrides: render } };
            case NodePackageManager.YARN:
            case NodePackageManager.YARN2:
            case NodePackageManager.YARN_CLASSIC:
            case NodePackageManager.YARN_BERRY:
            case NodePackageManager.BUN:
            default:
                return { resolutions: render };
        }
    }
    renderPublishConfig() {
        // When npm provenance is enabled, we need to always render the public access
        // But when npmAccess is the set to the default, we prefer to omit it
        const shouldOmitAccess = !this.npmProvenance &&
            this.npmAccess === defaultNpmAccess(this.packageName);
        // omit values if they are the same as the npm defaults
        return (0, _resolve_1.resolve)({
            registry: this.npmRegistryUrl !== DEFAULT_NPM_REGISTRY_URL
                ? this.npmRegistryUrl
                : undefined,
            access: shouldOmitAccess ? undefined : this.npmAccess,
        }, { omitEmpty: true });
    }
    renderKeywords() {
        const kwds = Array.from(this.keywords);
        return (0, util_2.sorted)(kwds.sort());
    }
    renderEngines() {
        return (0, util_2.sorted)(this.engines);
    }
    autoDiscoverBinaries() {
        const binrel = "bin";
        const bindir = (0, path_1.join)(this.project.outdir, binrel);
        if ((0, fs_1.existsSync)(bindir)) {
            for (const file of (0, fs_1.readdirSync)(bindir)) {
                try {
                    (0, fs_1.accessSync)((0, path_1.join)(bindir, file), fs_1.constants.X_OK);
                    const binPath = (0, path_1.join)(binrel, file);
                    const normalizedPath = (0, util_2.normalizePersistedPath)(binPath);
                    this.bin[file] = normalizedPath;
                }
                catch (e) {
                    // not executable, skip
                }
            }
        }
    }
    renderAuthor(options) {
        let author;
        if (options.authorName) {
            author = {
                name: options.authorName,
                email: options.authorEmail,
                url: options.authorUrl,
                organization: options.authorOrganization ?? false,
            };
        }
        else {
            if (options.authorEmail ||
                options.authorUrl ||
                options.authorOrganization !== undefined) {
                throw new Error('"authorName" is required if specifying "authorEmail" or "authorUrl"');
            }
        }
        return author;
    }
    renderBin() {
        return (0, util_2.sorted)(this.bin);
    }
    renderScripts() {
        const result = {};
        const tasks = this.project.tasks.all
            .filter((t) => 
        // Must remove to prevent overriding built-in npm command (which would loop)
        t.name !== this.installTask.name && t.name !== this.installCiTask.name)
            .sort((x, y) => x.name.localeCompare(y.name));
        for (const task of tasks) {
            if (this.scriptsToBeRemoved.has(task.name)) {
                continue;
            }
            result[task.name] = this.npmScriptForTask(task);
        }
        return {
            ...result,
            ...this.scripts,
        };
    }
    npmScriptForTask(task) {
        return `${this.projenCommand} ${task.name}`;
    }
    readPackageJson() {
        const file = (0, path_1.join)(this.project.outdir, "package.json");
        if (!(0, fs_1.existsSync)(file)) {
            return undefined;
        }
        return JSON.parse((0, fs_1.readFileSync)(file, "utf-8"));
    }
    installDependencies() {
        this.project.logger.info("Installing dependencies...");
        const runtime = new task_runtime_1.TaskRuntime(this.project.outdir);
        const taskToRun = this.isAutomatedBuild
            ? this.installCiTask
            : this.installTask;
        runtime.runTask(taskToRun.name);
    }
    configureYarnBerry(project, options) {
        const { version = "4.0.1", yarnRcOptions = {}, zeroInstalls = false, } = options.yarnBerryOptions || {};
        this.checkForConflictingYarnOptions(yarnRcOptions);
        // Set the `packageManager` field in `package.json` to the version specified. This tells `corepack` which version
        // of `yarn` to use.
        this.addField("packageManager", `yarn@${version}`);
        this.configureYarnBerryGitignore(zeroInstalls);
        new yarnrc_1.Yarnrc(project, version, yarnRcOptions);
    }
    checkForConflictingYarnOptions(yarnRcOptions) {
        if (this.npmAccess &&
            yarnRcOptions.npmPublishAccess &&
            this.npmAccess.toString() !== yarnRcOptions.npmPublishAccess.toString()) {
            throw new Error(`Cannot set npmAccess (${this.npmAccess}) and yarnRcOptions.npmPublishAccess (${yarnRcOptions.npmPublishAccess}) to different values.`);
        }
        if (this.npmRegistryUrl &&
            yarnRcOptions.npmRegistryServer &&
            this.npmRegistryUrl !== yarnRcOptions.npmRegistryServer) {
            throw new Error(`Cannot set npmRegistryUrl (${this.npmRegistryUrl}) and yarnRcOptions.npmRegistryServer (${yarnRcOptions.npmRegistryServer}) to different values.`);
        }
    }
    /** See https://yarnpkg.com/getting-started/qa#which-files-should-be-gitignored */
    configureYarnBerryGitignore(zeroInstalls) {
        const { gitignore } = this.project;
        // These patterns are the same whether or not you're using zero-installs
        gitignore.exclude(".yarn/*");
        gitignore.include(".yarn/patches", ".yarn/plugins", ".yarn/releases", ".yarn/sdks", ".yarn/versions");
        if (zeroInstalls) {
            gitignore.include("!.yarn/cache");
        }
        else {
            gitignore.exclude(".pnp.*");
        }
    }
}
exports.NodePackage = NodePackage;
_a = JSII_RTTI_SYMBOL_1;
NodePackage[_a] = { fqn: "projen.javascript.NodePackage", version: "0.88.0" };
/**
 * The node package manager to use.
 */
var NodePackageManager;
(function (NodePackageManager) {
    /**
     * Use `yarn` as the package manager.
     *
     * @deprecated For `yarn` 1.x use `YARN_CLASSIC` for `yarn` >= 2 use `YARN_BERRY`. Currently, `NodePackageManager.YARN` means `YARN_CLASSIC`. In the future, we might repurpose it to mean `YARN_BERRY`.
     */
    NodePackageManager["YARN"] = "yarn";
    /**
     * Use `yarn` versions >= 2 as the package manager.
     *
     * @deprecated use YARN_BERRY instead
     */
    NodePackageManager["YARN2"] = "yarn2";
    /**
     * Use `yarn` 1.x as the package manager.
     */
    NodePackageManager["YARN_CLASSIC"] = "yarn_classic";
    /**
     * Use `yarn` versions >= 2 as the package manager.
     */
    NodePackageManager["YARN_BERRY"] = "yarn_berry";
    /**
     * Use `npm` as the package manager.
     */
    NodePackageManager["NPM"] = "npm";
    /**
     * Use `pnpm` as the package manager.
     */
    NodePackageManager["PNPM"] = "pnpm";
    /**
     * Use `bun` as the package manager
     */
    NodePackageManager["BUN"] = "bun";
})(NodePackageManager || (exports.NodePackageManager = NodePackageManager = {}));
/**
 * Npm package access level
 */
var NpmAccess;
(function (NpmAccess) {
    /**
     * Package is public.
     */
    NpmAccess["PUBLIC"] = "public";
    /**
     * Package can only be accessed with credentials.
     */
    NpmAccess["RESTRICTED"] = "restricted";
})(NpmAccess || (exports.NpmAccess = NpmAccess = {}));
/**
 * Determines if an npm package is "scoped" (i.e. it starts with "xxx@").
 */
function isScoped(packageName) {
    return packageName.includes("@");
}
function defaultNpmAccess(packageName) {
    return isScoped(packageName) ? NpmAccess.RESTRICTED : NpmAccess.PUBLIC;
}
function defaultNpmToken(npmToken, registry) {
    // if we are publishing to AWS CdodeArtifact, no NPM_TOKEN used (will be requested using AWS CLI later).
    if ((0, release_1.isAwsCodeArtifactRegistry)(registry)) {
        return undefined;
    }
    // if we are publishing to GitHub Packages, default to GITHUB_TOKEN.
    const isGitHubPackages = registry === GITHUB_PACKAGES_REGISTRY;
    return (npmToken ??
        (isGitHubPackages ? DEFAULT_GITHUB_TOKEN_SECRET : DEFAULT_NPM_TOKEN_SECRET));
}
function determineLockfile(packageManager) {
    if (packageManager === NodePackageManager.YARN ||
        packageManager === NodePackageManager.YARN2 ||
        packageManager === NodePackageManager.YARN_CLASSIC ||
        packageManager === NodePackageManager.YARN_BERRY) {
        return "yarn.lock";
    }
    else if (packageManager === NodePackageManager.NPM) {
        return "package-lock.json";
    }
    else if (packageManager === NodePackageManager.PNPM) {
        return "pnpm-lock.yaml";
    }
    else if (packageManager === NodePackageManager.BUN) {
        return "bun.lockb";
    }
    throw new Error(`unsupported package manager ${packageManager}`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1wYWNrYWdlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2phdmFzY3JpcHQvbm9kZS1wYWNrYWdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFzdERBLDBDQWVDOztBQXJ1REQsMkJBTVk7QUFDWiwrQkFBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLGlDQUlnQjtBQUNoQixxQ0FBaUQ7QUFDakQsMENBQXFEO0FBQ3JELDRDQUF5QztBQUN6QyxrREFBaUQ7QUFDakQsa0NBQW1DO0FBRW5DLHdDQUF1RDtBQUV2RCxrREFBOEM7QUFDOUMsa0NBQThFO0FBRTlFLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQztBQUNoQyxNQUFNLHdCQUF3QixHQUFHLDZCQUE2QixDQUFDO0FBQy9ELE1BQU0sd0JBQXdCLEdBQUcsb0JBQW9CLENBQUM7QUFDdEQsTUFBTSx3QkFBd0IsR0FBRyxXQUFXLENBQUM7QUFDN0MsTUFBTSwyQkFBMkIsR0FBRyxjQUFjLENBQUM7QUFtVW5EOztHQUVHO0FBQ0gsSUFBWSx3QkFhWDtBQWJELFdBQVksd0JBQXdCO0lBQ2xDOztPQUVHO0lBQ0gscUZBQXlELENBQUE7SUFFekQ7Ozs7O09BS0c7SUFDSCx1REFBMkIsQ0FBQTtBQUM3QixDQUFDLEVBYlcsd0JBQXdCLHdDQUF4Qix3QkFBd0IsUUFhbkM7QUE4REQ7O0dBRUc7QUFDSCxNQUFhLFdBQVksU0FBUSxxQkFBUztJQUN4Qzs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBZ0I7UUFDL0IsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFZLEVBQW9CLEVBQUUsQ0FBQyxDQUFDLFlBQVksV0FBVyxDQUFDO1FBQzFFLE9BQU8sT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQTBIRCxZQUFZLE9BQWdCLEVBQUUsVUFBOEIsRUFBRTtRQUM1RCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7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QixDQUFDO0lBQzdCLENBQUM7U0FBTSxJQUFJLGNBQWMsS0FBSyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN0RCxPQUFPLGdCQUFnQixDQUFDO0lBQzFCLENBQUM7U0FBTSxJQUFJLGNBQWMsS0FBSyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNyRCxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDO0lBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsY0FBYyxFQUFFLENBQUMsQ0FBQztBQUNuRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYWNjZXNzU3luYyxcbiAgY29uc3RhbnRzLFxuICBleGlzdHNTeW5jLFxuICByZWFkZGlyU3luYyxcbiAgcmVhZEZpbGVTeW5jLFxufSBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gXCJzZW12ZXJcIjtcbmltcG9ydCB7XG4gIGV4dHJhY3RDb2RlQXJ0aWZhY3REZXRhaWxzLFxuICBtaW5WZXJzaW9uLFxuICB0cnlSZXNvbHZlRGVwZW5kZW5jeVZlcnNpb24sXG59IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7IFlhcm5yYywgWWFybnJjT3B0aW9ucyB9IGZyb20gXCIuL3lhcm5yY1wiO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlSnNvbiB9IGZyb20gXCIuLi9fcmVzb2x2ZVwiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgRGVwZW5kZW5jeVR5cGUgfSBmcm9tIFwiLi4vZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgeyBKc29uRmlsZSB9IGZyb20gXCIuLi9qc29uXCI7XG5pbXBvcnQgeyBQcm9qZWN0IH0gZnJvbSBcIi4uL3Byb2plY3RcIjtcbmltcG9ydCB7IGlzQXdzQ29kZUFydGlmYWN0UmVnaXN0cnkgfSBmcm9tIFwiLi4vcmVsZWFzZVwiO1xuaW1wb3J0IHsgVGFzayB9IGZyb20gXCIuLi90YXNrXCI7XG5pbXBvcnQgeyBUYXNrUnVudGltZSB9IGZyb20gXCIuLi90YXNrLXJ1bnRpbWVcIjtcbmltcG9ydCB7IGlzVHJ1dGh5LCBub3JtYWxpemVQZXJzaXN0ZWRQYXRoLCBzb3J0ZWQsIHdyaXRlRmlsZSB9IGZyb20gXCIuLi91dGlsXCI7XG5cbmNvbnN0IFVOTElDRU5TRUQgPSBcIlVOTElDRU5TRURcIjtcbmNvbnN0IERFRkFVTFRfTlBNX1JFR0lTVFJZX1VSTCA9IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXCI7XG5jb25zdCBHSVRIVUJfUEFDS0FHRVNfUkVHSVNUUlkgPSBcIm5wbS5wa2cuZ2l0aHViLmNvbVwiO1xuY29uc3QgREVGQVVMVF9OUE1fVE9LRU5fU0VDUkVUID0gXCJOUE1fVE9LRU5cIjtcbmNvbnN0IERFRkFVTFRfR0lUSFVCX1RPS0VOX1NFQ1JFVCA9IFwiR0lUSFVCX1RPS0VOXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZVBhY2thZ2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBcIm5hbWVcIiBpbiBwYWNrYWdlLmpzb25cbiAgICogQGRlZmF1bHQgLSBkZWZhdWx0cyB0byBwcm9qZWN0IG5hbWVcbiAgICogQGZlYXR1cmVkXG4gICAqL1xuICByZWFkb25seSBwYWNrYWdlTmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBpcyBqdXN0IGEgc3RyaW5nIHRoYXQgaGVscHMgcGVvcGxlIHVuZGVyc3RhbmQgdGhlIHB1cnBvc2Ugb2YgdGhlIHBhY2thZ2UuXG4gICAqIEl0IGNhbiBiZSB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciBwYWNrYWdlcyBpbiBhIHBhY2thZ2UgbWFuYWdlciBhcyB3ZWxsLlxuICAgKiBTZWUgaHR0cHM6Ly9jbGFzc2ljLnlhcm5wa2cuY29tL2VuL2RvY3MvcGFja2FnZS1qc29uLyN0b2MtZGVzY3JpcHRpb25cbiAgICogQGZlYXR1cmVkXG4gICAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAvKipcbiAgICogUnVudGltZSBkZXBlbmRlbmNpZXMgb2YgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqIFRoZSByZWNvbW1lbmRhdGlvbiBpcyB0byBvbmx5IHNwZWNpZnkgdGhlIG1vZHVsZSBuYW1lIGhlcmUgKGUuZy5cbiAgICogYGV4cHJlc3NgKS4gVGhpcyB3aWxsIGJlaGF2ZSBzaW1pbGFyIHRvIGB5YXJuIGFkZGAgb3IgYG5wbSBpbnN0YWxsYCBpbiB0aGVcbiAgICogc2Vuc2UgdGhhdCBpdCB3aWxsIGFkZCB0aGUgbW9kdWxlIGFzIGEgZGVwZW5kZW5jeSB0byB5b3VyIGBwYWNrYWdlLmpzb25gXG4gICAqIGZpbGUgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gKGBeYCkuIFlvdSBjYW4gc3BlY2lmeSBzZW12ZXIgcmVxdWlyZW1lbnRzIGluXG4gICAqIHRoZSBzYW1lIHN5bnRheCBwYXNzZWQgdG8gYG5wbSBpYCBvciBgeWFybiBhZGRgIChlLmcuIGBleHByZXNzQF4yYCkgYW5kXG4gICAqIHRoaXMgd2lsbCBiZSB3aGF0IHlvdSBgcGFja2FnZS5qc29uYCB3aWxsIGV2ZW50dWFsbHkgaW5jbHVkZS5cbiAgICpcbiAgICogQGV4YW1wbGUgWyAnZXhwcmVzcycsICdsb2Rhc2gnLCAnZm9vQF4yJyBdXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqIEBmZWF0dXJlZFxuICAgKi9cbiAgcmVhZG9ubHkgZGVwcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBCdWlsZCBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgbW9kdWxlLiBUaGVzZSBkZXBlbmRlbmNpZXMgd2lsbCBvbmx5IGJlXG4gICAqIGF2YWlsYWJsZSBpbiB5b3VyIGJ1aWxkIGVudmlyb25tZW50IGJ1dCB3aWxsIG5vdCBiZSBmZXRjaGVkIHdoZW4gdGhpc1xuICAgKiBtb2R1bGUgaXMgY29uc3VtZWQuXG4gICAqXG4gICAqIFRoZSByZWNvbW1lbmRhdGlvbiBpcyB0byBvbmx5IHNwZWNpZnkgdGhlIG1vZHVsZSBuYW1lIGhlcmUgKGUuZy5cbiAgICogYGV4cHJlc3NgKS4gVGhpcyB3aWxsIGJlaGF2ZSBzaW1pbGFyIHRvIGB5YXJuIGFkZGAgb3IgYG5wbSBpbnN0YWxsYCBpbiB0aGVcbiAgICogc2Vuc2UgdGhhdCBpdCB3aWxsIGFkZCB0aGUgbW9kdWxlIGFzIGEgZGVwZW5kZW5jeSB0byB5b3VyIGBwYWNrYWdlLmpzb25gXG4gICAqIGZpbGUgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gKGBeYCkuIFlvdSBjYW4gc3BlY2lmeSBzZW12ZXIgcmVxdWlyZW1lbnRzIGluXG4gICAqIHRoZSBzYW1lIHN5bnRheCBwYXNzZWQgdG8gYG5wbSBpYCBvciBgeWFybiBhZGRgIChlLmcuIGBleHByZXNzQF4yYCkgYW5kXG4gICAqIHRoaXMgd2lsbCBiZSB3aGF0IHlvdSBgcGFja2FnZS5qc29uYCB3aWxsIGV2ZW50dWFsbHkgaW5jbHVkZS5cbiAgICpcbiAgICogQGV4YW1wbGUgWyAndHlwZXNjcmlwdCcsICdAdHlwZXMvZXhwcmVzcycgXVxuICAgKiBAZGVmYXVsdCBbXVxuICAgKiBAZmVhdHVyZWRcbiAgICovXG4gIHJlYWRvbmx5IGRldkRlcHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogUGVlciBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgbW9kdWxlLiBEZXBlbmRlbmNpZXMgbGlzdGVkIGhlcmUgYXJlIHJlcXVpcmVkIHRvXG4gICAqIGJlIGluc3RhbGxlZCAoYW5kIHNhdGlzZmllZCkgYnkgdGhlIF9jb25zdW1lcl8gb2YgdGhpcyBsaWJyYXJ5LiBVc2luZyBwZWVyXG4gICAqIGRlcGVuZGVuY2llcyBhbGxvd3MgeW91IHRvIGVuc3VyZSB0aGF0IG9ubHkgYSBzaW5nbGUgbW9kdWxlIG9mIGEgY2VydGFpblxuICAgKiBsaWJyYXJ5IGV4aXN0cyBpbiB0aGUgYG5vZGVfbW9kdWxlc2AgdHJlZSBvZiB5b3VyIGNvbnN1bWVycy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHByaW9yIHRvIG5wbUA3LCBwZWVyIGRlcGVuZGVuY2llcyBhcmUgX25vdF8gYXV0b21hdGljYWxseVxuICAgKiBpbnN0YWxsZWQsIHdoaWNoIG1lYW5zIHRoYXQgYWRkaW5nIHBlZXIgZGVwZW5kZW5jaWVzIHRvIGEgbGlicmFyeSB3aWxsIGJlIGFcbiAgICogYnJlYWtpbmcgY2hhbmdlIGZvciB5b3VyIGN1c3RvbWVycy5cbiAgICpcbiAgICogVW5sZXNzIGBwZWVyRGVwZW5kZW5jeU9wdGlvbnMucGlubmVkRGV2RGVwZW5kZW5jeWAgaXMgZGlzYWJsZWQgKGl0IGlzXG4gICAqIGVuYWJsZWQgYnkgZGVmYXVsdCksIHByb2plbiB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIGEgZGV2IGRlcGVuZGVuY3kgd2l0aCBhXG4gICAqIHBpbm5lZCB2ZXJzaW9uIGZvciBlYWNoIHBlZXIgZGVwZW5kZW5jeS4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHlvdSBidWlsZCAmXG4gICAqIHRlc3QgeW91ciBtb2R1bGUgYWdhaW5zdCB0aGUgbG93ZXN0IHBlZXIgdmVyc2lvbiByZXF1aXJlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHJlYWRvbmx5IHBlZXJEZXBzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgZGVwZW5kZW5jaWVzIHRvIGJ1bmRsZSBpbnRvIHRoaXMgbW9kdWxlLiBUaGVzZSBtb2R1bGVzIHdpbGwgYmVcbiAgICogYWRkZWQgYm90aCB0byB0aGUgYGRlcGVuZGVuY2llc2Agc2VjdGlvbiBhbmQgYGJ1bmRsZWREZXBlbmRlbmNpZXNgIHNlY3Rpb24gb2ZcbiAgICogeW91ciBgcGFja2FnZS5qc29uYC5cbiAgICpcbiAgICogVGhlIHJlY29tbWVuZGF0aW9uIGlzIHRvIG9ubHkgc3BlY2lmeSB0aGUgbW9kdWxlIG5hbWUgaGVyZSAoZS5nLlxuICAgKiBgZXhwcmVzc2ApLiBUaGlzIHdpbGwgYmVoYXZlIHNpbWlsYXIgdG8gYHlhcm4gYWRkYCBvciBgbnBtIGluc3RhbGxgIGluIHRoZVxuICAgKiBzZW5zZSB0aGF0IGl0IHdpbGwgYWRkIHRoZSBtb2R1bGUgYXMgYSBkZXBlbmRlbmN5IHRvIHlvdXIgYHBhY2thZ2UuanNvbmBcbiAgICogZmlsZSB3aXRoIHRoZSBsYXRlc3QgdmVyc2lvbiAoYF5gKS4gWW91IGNhbiBzcGVjaWZ5IHNlbXZlciByZXF1aXJlbWVudHMgaW5cbiAgICogdGhlIHNhbWUgc3ludGF4IHBhc3NlZCB0byBgbnBtIGlgIG9yIGB5YXJuIGFkZGAgKGUuZy4gYGV4cHJlc3NAXjJgKSBhbmRcbiAgICogdGhpcyB3aWxsIGJlIHdoYXQgeW91IGBwYWNrYWdlLmpzb25gIHdpbGwgZXZlbnR1YWxseSBpbmNsdWRlLlxuICAgKi9cbiAgcmVhZG9ubHkgYnVuZGxlZERlcHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgYHBlZXJEZXBzYC5cbiAgICovXG4gIHJlYWRvbmx5IHBlZXJEZXBlbmRlbmN5T3B0aW9ucz86IFBlZXJEZXBlbmRlbmN5T3B0aW9ucztcblxuICAvKipcbiAgICogQWxsb3cgdGhlIHByb2plY3QgdG8gaW5jbHVkZSBgcGVlckRlcGVuZGVuY2llc2AgYW5kIGBidW5kbGVkRGVwZW5kZW5jaWVzYC5cbiAgICogVGhpcyBpcyBub3JtYWxseSBvbmx5IGFsbG93ZWQgZm9yIGxpYnJhcmllcy4gRm9yIGFwcHMsIHRoZXJlJ3Mgbm8gbWVhbmluZ1xuICAgKiBmb3Igc3BlY2lmeWluZyB0aGVzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dMaWJyYXJ5RGVwZW5kZW5jaWVzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogS2V5d29yZHMgdG8gaW5jbHVkZSBpbiBgcGFja2FnZS5qc29uYC5cbiAgICovXG4gIHJlYWRvbmx5IGtleXdvcmRzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBlbnRyeXBvaW50IChgbWFpbmAgaW4gYHBhY2thZ2UuanNvbmApXG4gICAqXG4gICAqIFNldCB0byBhbiBlbXB0eSBzdHJpbmcgdG8gbm90IGluY2x1ZGUgYG1haW5gIGluIHlvdXIgcGFja2FnZS5qc29uXG4gICAqXG4gICAqIEBkZWZhdWx0IFwibGliL2luZGV4LmpzXCJcbiAgICovXG4gIHJlYWRvbmx5IGVudHJ5cG9pbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEJpbmFyeSBwcm9ncmFtcyB2ZW5kZWQgd2l0aCB5b3VyIG1vZHVsZS5cbiAgICpcbiAgICogWW91IGNhbiB1c2UgdGhpcyBvcHRpb24gdG8gYWRkL2N1c3RvbWl6ZSBob3cgYmluYXJpZXMgYXJlIHJlcHJlc2VudGVkIGluXG4gICAqIHlvdXIgYHBhY2thZ2UuanNvbmAsIGJ1dCB1bmxlc3MgYGF1dG9EZXRlY3RCaW5gIGlzIGBmYWxzZWAsIGV2ZXJ5XG4gICAqIGV4ZWN1dGFibGUgZmlsZSB1bmRlciBgYmluYCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgYWRkZWQgdG8gdGhpcyBzZWN0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgYmluPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAvKipcbiAgICogQXV0b21hdGljYWxseSBhZGQgYWxsIGV4ZWN1dGFibGVzIHVuZGVyIHRoZSBgYmluYCBkaXJlY3RvcnkgdG8geW91clxuICAgKiBgcGFja2FnZS5qc29uYCBmaWxlIHVuZGVyIHRoZSBgYmluYCBzZWN0aW9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBhdXRvRGV0ZWN0QmluPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogbnBtIHNjcmlwdHMgdG8gaW5jbHVkZS4gSWYgYSBzY3JpcHQgaGFzIHRoZSBzYW1lIG5hbWUgYXMgYSBzdGFuZGFyZCBzY3JpcHQsXG4gICAqIHRoZSBzdGFuZGFyZCBzY3JpcHQgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICogQWxzbyBhZGRzIHRoZSBzY3JpcHQgYXMgYSB0YXNrLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHByb2plY3QuYWRkVGFzaygpYCBvciBgcGFja2FnZS5zZXRTY3JpcHQoKWBcbiAgICovXG4gIHJlYWRvbmx5IHNjcmlwdHM/OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogVGhlIE5vZGUgUGFja2FnZSBNYW5hZ2VyIHVzZWQgdG8gZXhlY3V0ZSBzY3JpcHRzXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vZGVQYWNrYWdlTWFuYWdlci5ZQVJOX0NMQVNTSUNcbiAgICovXG4gIHJlYWRvbmx5IHBhY2thZ2VNYW5hZ2VyPzogTm9kZVBhY2thZ2VNYW5hZ2VyO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVwb3NpdG9yeSBpcyB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIGFjdHVhbCBjb2RlIGZvciB5b3VyIHBhY2thZ2UgbGl2ZXMuXG4gICAqIFNlZSBodHRwczovL2NsYXNzaWMueWFybnBrZy5jb20vZW4vZG9jcy9wYWNrYWdlLWpzb24vI3RvYy1yZXBvc2l0b3J5XG4gICAqL1xuICByZWFkb25seSByZXBvc2l0b3J5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgcGFja2FnZS5qc29uIGZvciB5b3VyIHBhY2thZ2UgaXMgbm90IGluIHRoZSByb290IGRpcmVjdG9yeSAoZm9yIGV4YW1wbGUgaWYgaXQgaXMgcGFydCBvZiBhIG1vbm9yZXBvKSxcbiAgICogeW91IGNhbiBzcGVjaWZ5IHRoZSBkaXJlY3RvcnkgaW4gd2hpY2ggaXQgbGl2ZXMuXG4gICAqL1xuICByZWFkb25seSByZXBvc2l0b3J5RGlyZWN0b3J5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBdXRob3IncyBuYW1lXG4gICAqL1xuICByZWFkb25seSBhdXRob3JOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBdXRob3IncyBlLW1haWxcbiAgICovXG4gIHJlYWRvbmx5IGF1dGhvckVtYWlsPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBdXRob3IncyBVUkwgLyBXZWJzaXRlXG4gICAqL1xuICByZWFkb25seSBhdXRob3JVcmw/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElzIHRoZSBhdXRob3IgYW4gb3JnYW5pemF0aW9uXG4gICAqL1xuICByZWFkb25seSBhdXRob3JPcmdhbml6YXRpb24/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBQYWNrYWdlJ3MgSG9tZXBhZ2UgLyBXZWJzaXRlXG4gICAqL1xuICByZWFkb25seSBob21lcGFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogUGFja2FnZSdzIFN0YWJpbGl0eVxuICAgKi9cbiAgcmVhZG9ubHkgc3RhYmlsaXR5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBub2RlIHZlcnNpb24gcmVxdWlyZWQgYnkgdGhpcyBwYWNrYWdlIHRvIGZ1bmN0aW9uLlxuICAgKiBNb3N0IHByb2plY3RzIHNob3VsZCBub3QgdXNlIHRoaXMgb3B0aW9uLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHBhY2thZ2UgaXMgaW5jb21wYXRpYmxlIHdpdGggYW55IG9sZGVyIHZlcnNpb25zIG9mIG5vZGUuXG4gICAqIFRoaXMgcmVxdWlyZW1lbnQgaXMgZW5mb3JjZWQgdmlhIHRoZSBlbmdpbmVzIGZpZWxkLlxuICAgKlxuICAgKiBZb3Ugd2lsbCBub3JtYWxseSBub3QgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24sIGV2ZW4gaWYgeW91ciBwYWNrYWdlIGlzIGluY29tcGF0aWJsZSB3aXRoIEVPTCB2ZXJzaW9ucyBvZiBub2RlLlxuICAgKiBDb25zaWRlciB0aGlzIG9wdGlvbiBvbmx5IGlmIHlvdXIgcGFja2FnZSBkZXBlbmRzIG9uIGEgc3BlY2lmaWMgZmVhdHVyZSwgdGhhdCBpcyBub3QgYXZhaWxhYmxlIGluIG90aGVyIExUUyB2ZXJzaW9ucy5cbiAgICogU2V0dGluZyB0aGlzIG9wdGlvbiBoYXMgdmVyeSBoaWdoIGltcGFjdCBvbiB0aGUgY29uc3VtZXJzIG9mIHlvdXIgcGFja2FnZSxcbiAgICogYXMgcGFja2FnZSBtYW5hZ2VycyB3aWxsIGFjdGl2ZWx5IHByZXZlbnQgdXNhZ2Ugd2l0aCBub2RlIHZlcnNpb25zIHlvdSBoYXZlIG1hcmtlZCBhcyBpbmNvbXBhdGlibGUuXG4gICAqXG4gICAqIFRvIGNoYW5nZSB0aGUgbm9kZSB2ZXJzaW9uIG9mIHlvdXIgQ0kvQ0Qgd29ya2Zsb3dzLCB1c2UgYHdvcmtmbG93Tm9kZVZlcnNpb25gLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIG1pbmltdW0gdmVyc2lvbiBpcyBlbmZvcmNlZFxuXG4gICAqL1xuICByZWFkb25seSBtaW5Ob2RlVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbm9kZSB2ZXJzaW9uIHN1cHBvcnRlZCBieSB0aGlzIHBhY2thZ2UuXG4gICAqIE1vc3QgcHJvamVjdHMgc2hvdWxkIG5vdCB1c2UgdGhpcyBvcHRpb24uXG4gICAqXG4gICAqIFRoZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgcGFja2FnZSBpcyBpbmNvbXBhdGlibGUgd2l0aCBhbnkgbmV3ZXIgdmVyc2lvbnMgb2Ygbm9kZS5cbiAgICogVGhpcyByZXF1aXJlbWVudCBpcyBlbmZvcmNlZCB2aWEgdGhlIGVuZ2luZXMgZmllbGQuXG4gICAqXG4gICAqIFlvdSB3aWxsIG5vcm1hbGx5IG5vdCBuZWVkIHRvIHNldCB0aGlzIG9wdGlvbi5cbiAgICogQ29uc2lkZXIgdGhpcyBvcHRpb24gb25seSBpZiB5b3VyIHBhY2thZ2UgaXMga25vd24gdG8gbm90IGZ1bmN0aW9uIHdpdGggbmV3ZXIgdmVyc2lvbnMgb2Ygbm9kZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBtYXhpbXVtIHZlcnNpb24gaXMgZW5mb3JjZWRcbiAgICovXG4gIHJlYWRvbmx5IG1heE5vZGVWZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiBQTlBNIHRvIHVzZSBpZiB1c2luZyBQTlBNIGFzIGEgcGFja2FnZSBtYW5hZ2VyLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcIjdcIlxuICAgKi9cbiAgcmVhZG9ubHkgcG5wbVZlcnNpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExpY2Vuc2UncyBTUERYIGlkZW50aWZpZXIuXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvamVuL3Byb2plbi90cmVlL21haW4vbGljZW5zZS10ZXh0IGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIGxpY2Vuc2VzLlxuICAgKiBVc2UgdGhlIGBsaWNlbnNlZGAgb3B0aW9uIGlmIHlvdSB3YW50IHRvIG5vIGxpY2Vuc2UgdG8gYmUgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcIkFwYWNoZS0yLjBcIlxuICAgKi9cbiAgcmVhZG9ubHkgbGljZW5zZT86IHN0cmluZztcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIGEgbGljZW5zZSBzaG91bGQgYmUgYWRkZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGxpY2Vuc2VkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGJhc2UgVVJMIG9mIHRoZSBucG0gcGFja2FnZSByZWdpc3RyeS5cbiAgICpcbiAgICogTXVzdCBiZSBhIFVSTCAoZS5nLiBzdGFydCB3aXRoIFwiaHR0cHM6Ly9cIiBvciBcImh0dHA6Ly9cIilcbiAgICpcbiAgICogQGRlZmF1bHQgXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZ1wiXG4gICAqL1xuICByZWFkb25seSBucG1SZWdpc3RyeVVybD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGhvc3QgbmFtZSBvZiB0aGUgbnBtIHJlZ2lzdHJ5IHRvIHB1Ymxpc2ggdG8uIENhbm5vdCBiZSBzZXQgdG9nZXRoZXIgd2l0aCBgbnBtUmVnaXN0cnlVcmxgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYG5wbVJlZ2lzdHJ5VXJsYCBpbnN0ZWFkXG4gICAqL1xuICByZWFkb25seSBucG1SZWdpc3RyeT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVybCB0byB5b3VyIHByb2plY3QncyBpc3N1ZSB0cmFja2VyLlxuICAgKi9cbiAgcmVhZG9ubHkgYnVnc1VybD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVtYWlsIGFkZHJlc3MgdG8gd2hpY2ggaXNzdWVzIHNob3VsZCBiZSByZXBvcnRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGJ1Z3NFbWFpbD86IHN0cmluZztcblxuICAvKipcbiAgICogQWNjZXNzIGxldmVsIG9mIHRoZSBucG0gcGFja2FnZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBmb3Igc2NvcGVkIHBhY2thZ2VzIChlLmcuIGBmb29AYmFyYCksIHRoZSBkZWZhdWx0IGlzXG4gICAqIGBOcG1BY2Nlc3MuUkVTVFJJQ1RFRGAsIGZvciBub24tc2NvcGVkIHBhY2thZ2VzLCB0aGUgZGVmYXVsdCBpc1xuICAgKiBgTnBtQWNjZXNzLlBVQkxJQ2AuXG4gICAqL1xuICByZWFkb25seSBucG1BY2Nlc3M/OiBOcG1BY2Nlc3M7XG5cbiAgLyoqXG4gICAqIFNob3VsZCBwcm92ZW5hbmNlIHN0YXRlbWVudHMgYmUgZ2VuZXJhdGVkIHdoZW4gdGhlIHBhY2thZ2UgaXMgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHN1cHBvcnRlZCBwYWNrYWdlIG1hbmFnZXIgaXMgcmVxdWlyZWQgdG8gcHVibGlzaCBhIHBhY2thZ2Ugd2l0aCBucG0gcHJvdmVuYW5jZSBzdGF0ZW1lbnRzIGFuZFxuICAgKiB5b3Ugd2lsbCBuZWVkIHRvIHVzZSBhIHN1cHBvcnRlZCBDSS9DRCBwcm92aWRlci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBwcm9qZW4gYFJlbGVhc2VgIGFuZCBgUHVibGlzaGVyYCBjb21wb25lbnRzIGFyZSB1c2luZyBgcHVibGliYCB0byBwdWJsaXNoIHBhY2thZ2VzLFxuICAgKiB3aGljaCBpcyB1c2luZyBucG0gaW50ZXJuYWxseSBhbmQgc3VwcG9ydHMgcHJvdmVuYW5jZSBzdGF0ZW1lbnRzIGluZGVwZW5kZW50bHkgb2YgdGhlIHBhY2thZ2UgbWFuYWdlciB1c2VkLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vZ2VuZXJhdGluZy1wcm92ZW5hbmNlLXN0YXRlbWVudHNcbiAgICogQGRlZmF1bHQgLSB0cnVlIGZvciBwdWJsaWMgcGFja2FnZXMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcmVhZG9ubHkgbnBtUHJvdmVuYW5jZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdpdEh1YiBzZWNyZXQgd2hpY2ggY29udGFpbnMgdGhlIE5QTSB0b2tlbiB0byB1c2Ugd2hlbiBwdWJsaXNoaW5nIHBhY2thZ2VzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcIk5QTV9UT0tFTlwiXG4gICAqL1xuICByZWFkb25seSBucG1Ub2tlblNlY3JldD86IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgbnBtIHBhY2thZ2VzIHVzaW5nIEFXUyBDb2RlQXJ0aWZhY3QuXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgaWYgcHVibGlzaGluZyBwYWNrYWdlcyB0bywgb3IgaW5zdGFsbGluZyBzY29wZWQgcGFja2FnZXMgZnJvbSBBV1MgQ29kZUFydGlmYWN0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSBjb2RlQXJ0aWZhY3RPcHRpb25zPzogQ29kZUFydGlmYWN0T3B0aW9ucztcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgcHJpdmF0ZWx5IGhvc3RlZCBzY29wZWQgcGFja2FnZXNcbiAgICpcbiAgICogQGRlZmF1bHQgLSBmZXRjaCBhbGwgc2NvcGVkIHBhY2thZ2VzIGZyb20gdGhlIHB1YmxpYyBucG0gcmVnaXN0cnlcbiAgICovXG4gIHJlYWRvbmx5IHNjb3BlZFBhY2thZ2VzT3B0aW9ucz86IFNjb3BlZFBhY2thZ2VzT3B0aW9uc1tdO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBZYXJuIEJlcnJ5XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gWWFybiBCZXJyeSB2NCB3aXRoIGFsbCBkZWZhdWx0IG9wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IHlhcm5CZXJyeU9wdGlvbnM/OiBZYXJuQmVycnlPcHRpb25zO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGF1dGhvcml6aW5nIHJlcXVlc3RzIHRvIGEgQVdTIENvZGVBcnRpZmFjdCBucG0gcmVwb3NpdG9yeS5cbiAqL1xuZXhwb3J0IGVudW0gQ29kZUFydGlmYWN0QXV0aFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIEZpeGVkIGNyZWRlbnRpYWxzIHByb3ZpZGVkIHZpYSBHaXRodWIgc2VjcmV0cy5cbiAgICovXG4gIEFDQ0VTU19BTkRfU0VDUkVUX0tFWV9QQUlSID0gXCJBQ0NFU1NfQU5EX1NFQ1JFVF9LRVlfUEFJUlwiLFxuXG4gIC8qKlxuICAgKiBFcGhlbWVyYWwgY3JlZGVudGlhbHMgcHJvdmlkZWQgdmlhIEdpdGh1YidzIE9JREMgaW50ZWdyYXRpb24gd2l0aCBhbiBJQU0gcm9sZS5cbiAgICogU2VlOlxuICAgKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9Vc2VyR3VpZGUvaWRfcm9sZXNfcHJvdmlkZXJzX2NyZWF0ZV9vaWRjLmh0bWxcbiAgICogaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucy9kZXBsb3ltZW50L3NlY3VyaXR5LWhhcmRlbmluZy15b3VyLWRlcGxveW1lbnRzL2NvbmZpZ3VyaW5nLW9wZW5pZC1jb25uZWN0LWluLWFtYXpvbi13ZWItc2VydmljZXNcbiAgICovXG4gIEdJVEhVQl9PSURDID0gXCJHSVRIVUJfT0lEQ1wiLFxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHB1Ymxpc2hpbmcgbnBtIHBhY2thZ2VzIHRvIEFXUyBDb2RlQXJ0aWZhY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUFydGlmYWN0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQcm92aWRlciB0byB1c2UgZm9yIGF1dGhvcml6aW5nIHJlcXVlc3RzIHRvIEFXUyBDb2RlQXJ0aWZhY3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IENvZGVBcnRpZmFjdEF1dGhQcm92aWRlci5BQ0NFU1NfQU5EX1NFQ1JFVF9LRVlfUEFJUlxuICAgKi9cbiAgcmVhZG9ubHkgYXV0aFByb3ZpZGVyPzogQ29kZUFydGlmYWN0QXV0aFByb3ZpZGVyO1xuXG4gIC8qKlxuICAgKiBHaXRIdWIgc2VjcmV0IHdoaWNoIGNvbnRhaW5zIHRoZSBBV1MgYWNjZXNzIGtleSBJRCB0byB1c2Ugd2hlbiBwdWJsaXNoaW5nIHBhY2thZ2VzIHRvIEFXUyBDb2RlQXJ0aWZhY3QuXG4gICAqIFRoaXMgcHJvcGVydHkgbXVzdCBiZSBzcGVjaWZpZWQgb25seSB3aGVuIHB1Ymxpc2hpbmcgdG8gQVdTIENvZGVBcnRpZmFjdCAoYG5wbVJlZ2lzdHJ5VXJsYCBjb250YWlucyBBV1MgQ29kZUFydGlmYWN0IFVSTCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gV2hlbiB0aGUgYGF1dGhQcm92aWRlcmAgdmFsdWUgaXMgc2V0IHRvXG4gICAqIGBDb2RlQXJ0aWZhY3RBdXRoUHJvdmlkZXIuQUNDRVNTX0FORF9TRUNSRVRfS0VZX1BBSVJgLCB0aGUgZGVmYXVsdCBpc1xuICAgKiBcIkFXU19BQ0NFU1NfS0VZX0lEXCIuIEZvciBgQ29kZUFydGlmYWN0QXV0aFByb3ZpZGVyLkdJVEhVQl9PSURDYCwgdGhpc1xuICAgKiB2YWx1ZSBtdXN0IGJlIGxlZnQgdW5kZWZpbmVkLlxuICAgKi9cbiAgcmVhZG9ubHkgYWNjZXNzS2V5SWRTZWNyZXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdpdEh1YiBzZWNyZXQgd2hpY2ggY29udGFpbnMgdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleSB0byB1c2Ugd2hlbiBwdWJsaXNoaW5nIHBhY2thZ2VzIHRvIEFXUyBDb2RlQXJ0aWZhY3QuXG4gICAqIFRoaXMgcHJvcGVydHkgbXVzdCBiZSBzcGVjaWZpZWQgb25seSB3aGVuIHB1Ymxpc2hpbmcgdG8gQVdTIENvZGVBcnRpZmFjdCAoYG5wbVJlZ2lzdHJ5VXJsYCBjb250YWlucyBBV1MgQ29kZUFydGlmYWN0IFVSTCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gV2hlbiB0aGUgYGF1dGhQcm92aWRlcmAgdmFsdWUgaXMgc2V0IHRvXG4gICAqIGBDb2RlQXJ0aWZhY3RBdXRoUHJvdmlkZXIuQUNDRVNTX0FORF9TRUNSRVRfS0VZX1BBSVJgLCB0aGUgZGVmYXVsdCBpc1xuICAgKiBcIkFXU19TRUNSRVRfQUNDRVNTX0tFWVwiLiBGb3IgYENvZGVBcnRpZmFjdEF1dGhQcm92aWRlci5HSVRIVUJfT0lEQ2AsIHRoaXNcbiAgICogdmFsdWUgbXVzdCBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAgICovXG4gIHJlYWRvbmx5IHNlY3JldEFjY2Vzc0tleVNlY3JldD86IHN0cmluZztcblxuICAvKipcbiAgICogQVJOIG9mIEFXUyByb2xlIHRvIGJlIGFzc3VtZWQgcHJpb3IgdG8gZ2V0IGF1dGhvcml6YXRpb24gdG9rZW4gZnJvbSBBV1MgQ29kZUFydGlmYWN0XG4gICAqIFRoaXMgcHJvcGVydHkgbXVzdCBiZSBzcGVjaWZpZWQgb25seSB3aGVuIHB1Ymxpc2hpbmcgdG8gQVdTIENvZGVBcnRpZmFjdCAoYHJlZ2lzdHJ5YCBjb250YWlucyBBV1MgQ29kZUFydGlmYWN0IFVSTCkuXG4gICAqIFdoZW4gdXNpbmcgdGhlIGBDb2RlQXJ0aWZhY3RBdXRoUHJvdmlkZXIuR0lUSFVCX09JRENgIGF1dGggcHJvdmlkZXIsIHRoaXMgdmFsdWUgbXVzdCBiZSBkZWZpbmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IHJvbGVUb0Fzc3VtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzY29wZWQgcGFja2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTY29wZWRQYWNrYWdlc09wdGlvbnMge1xuICAvKipcbiAgICogU2NvcGUgb2YgdGhlIHBhY2thZ2VzXG4gICAqXG4gICAqIEBleGFtcGxlIFwiQGFuZ3VsYXJcIlxuICAgKi9cbiAgcmVhZG9ubHkgc2NvcGU6IHN0cmluZztcblxuICAvKipcbiAgICogVVJMIG9mIHRoZSByZWdpc3RyeSBmb3Igc2NvcGVkIHBhY2thZ2VzXG4gICAqL1xuICByZWFkb25seSByZWdpc3RyeVVybDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG5wbSBgcGFja2FnZS5qc29uYCBmaWxlLlxuICovXG5leHBvcnQgY2xhc3MgTm9kZVBhY2thZ2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYE5vZGVQYWNrYWdlYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggYSBwcm9qZWN0IG9yIGB1bmRlZmluZWRgIGlmXG4gICAqIHRoZXJlIGlzIG5vIE5vZGVQYWNrYWdlLlxuICAgKiBAcGFyYW0gcHJvamVjdCBUaGUgcHJvamVjdFxuICAgKiBAcmV0dXJucyBBIE5vZGVQYWNrYWdlLCBvciB1bmRlZmluZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgb2YocHJvamVjdDogUHJvamVjdCk6IE5vZGVQYWNrYWdlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpc0l0ID0gKG86IENvbXBvbmVudCk6IG8gaXMgTm9kZVBhY2thZ2UgPT4gbyBpbnN0YW5jZW9mIE5vZGVQYWNrYWdlO1xuICAgIHJldHVybiBwcm9qZWN0LmNvbXBvbmVudHMuZmluZChpc0l0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbnBtIHBhY2thZ2UuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcGFja2FnZU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1vZHVsZSdzIGVudHJ5cG9pbnQgKGUuZy4gYGxpYi9pbmRleC5qc2ApLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGVudHJ5cG9pbnQ6IHN0cmluZztcblxuICAvKipcbiAgICogQWxsb3cgcHJvamVjdCB0byB0YWtlIGxpYnJhcnkgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGFsbG93TGlicmFyeURlcGVuZGVuY2llczogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcGFja2FnZU1hbmFnZXI6IE5vZGVQYWNrYWdlTWFuYWdlcjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBhZGRGaWVsZCh4LCB5KWBcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtYW5pZmVzdDogYW55O1xuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBub2RlIHZlcnNpb24gcmVxdWlyZWQgYnkgdGhpcyBwYWNrYWdlIHRvIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIGluZGljYXRlcyB0aGUgcGFja2FnZSBpcyBpbmNvbXBhdGlibGUgd2l0aCBvbGRlciB2ZXJzaW9ucy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtaW5Ob2RlVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogTWF4aW11bSBub2RlIHZlcnNpb24gc3VwcG9ydGVkIGJ5IHRoaXMgcGFja2FnZS5cbiAgICpcbiAgICogVGhlIHZhbHVlIGluZGljYXRlcyB0aGUgcGFja2FnZSBpcyBpbmNvbXBhdGlibGUgd2l0aCBuZXdlciB2ZXJzaW9ucy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtYXhOb2RlVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgUE5QTSB0byB1c2UgaWYgdXNpbmcgUE5QTSBhcyBhIHBhY2thZ2UgbWFuYWdlci5cbiAgICpcbiAgICogQGRlZmF1bHQgXCI3XCJcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwbnBtVmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFNQRFggbGljZW5zZSBvZiB0aGlzIG1vZHVsZS4gYHVuZGVmaW5lZGAgaWYgdGhpcyBwYWNrYWdlIGlzIG5vdCBsaWNlbnNlZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsaWNlbnNlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBucG0gcmVnaXN0cnkgKGUuZy4gYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnYCkuIFVzZSBgbnBtUmVnaXN0cnlIb3N0YCB0byBnZXQganVzdCB0aGUgaG9zdCBuYW1lLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG5wbVJlZ2lzdHJ5VXJsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBucG0gcmVnaXN0cnkgaG9zdCAoZS5nLiBgcmVnaXN0cnkubnBtanMub3JnYCkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbnBtUmVnaXN0cnk6IHN0cmluZztcblxuICAvKipcbiAgICogR2l0SHViIHNlY3JldCB3aGljaCBjb250YWlucyB0aGUgTlBNIHRva2VuIHRvIHVzZSB3aGVuIHB1Ymxpc2hpbmcgcGFja2FnZXMuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbnBtVG9rZW5TZWNyZXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIG5wbSBwYWNrYWdlcyB1c2luZyBBV1MgQ29kZUFydGlmYWN0LlxuICAgKiBUaGlzIGlzIHJlcXVpcmVkIGlmIHB1Ymxpc2hpbmcgcGFja2FnZXMgdG8sIG9yIGluc3RhbGxpbmcgc2NvcGVkIHBhY2thZ2VzIGZyb20gQVdTIENvZGVBcnRpZmFjdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgY29kZUFydGlmYWN0T3B0aW9ucz86IENvZGVBcnRpZmFjdE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHByaXZhdGVseSBob3N0ZWQgc2NvcGVkIHBhY2thZ2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgc2NvcGVkUGFja2FnZXNPcHRpb25zPzogU2NvcGVkUGFja2FnZXNPcHRpb25zW107XG5cbiAgLyoqXG4gICAqIG5wbSBwYWNrYWdlIGFjY2VzcyBsZXZlbC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBucG1BY2Nlc3M6IE5wbUFjY2VzcztcblxuICAvKipcbiAgICogU2hvdWxkIHByb3ZlbmFuY2Ugc3RhdGVtZW50cyBiZSBnZW5lcmF0ZWQgd2hlbiBwYWNrYWdlIGlzIHB1Ymxpc2hlZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBucG1Qcm92ZW5hbmNlOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbG9jayBmaWxlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGxvY2tGaWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0YXNrIGZvciBpbnN0YWxsaW5nIHByb2plY3QgZGVwZW5kZW5jaWVzIChub24tZnJvemVuKVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGluc3RhbGxUYXNrOiBUYXNrO1xuXG4gIC8qKlxuICAgKiBUaGUgdGFzayBmb3IgaW5zdGFsbGluZyBwcm9qZWN0IGRlcGVuZGVuY2llcyAoZnJvemVuKVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGluc3RhbGxDaVRhc2s6IFRhc2s7XG5cbiAgLyoqXG4gICAqIFRoZSBwYWNrYWdlLmpzb24gZmlsZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBmaWxlOiBKc29uRmlsZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHNjcmlwdHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgcHJpdmF0ZSByZWFkb25seSBzY3JpcHRzVG9CZVJlbW92ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBrZXl3b3JkczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmluOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5naW5lczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBwcml2YXRlIHJlYWRvbmx5IHBlZXJEZXBlbmRlbmN5T3B0aW9uczogUGVlckRlcGVuZGVuY3lPcHRpb25zO1xuICBwcml2YXRlIHJlYWRvbmx5IF9wcmV2PzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcHJpdmF0ZSBfcmVuZGVyZWREZXBzPzogTnBtRGVwZW5kZW5jaWVzO1xuXG4gIGNvbnN0cnVjdG9yKHByb2plY3Q6IFByb2plY3QsIG9wdGlvbnM6IE5vZGVQYWNrYWdlT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIocHJvamVjdCk7XG5cbiAgICB0aGlzLnBhY2thZ2VOYW1lID0gb3B0aW9ucy5wYWNrYWdlTmFtZSA/PyBwcm9qZWN0Lm5hbWU7XG4gICAgdGhpcy5wZWVyRGVwZW5kZW5jeU9wdGlvbnMgPSB7XG4gICAgICBwaW5uZWREZXZEZXBlbmRlbmN5OiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucy5wZWVyRGVwZW5kZW5jeU9wdGlvbnMsXG4gICAgfTtcbiAgICB0aGlzLmFsbG93TGlicmFyeURlcGVuZGVuY2llcyA9IG9wdGlvbnMuYWxsb3dMaWJyYXJ5RGVwZW5kZW5jaWVzID8/IHRydWU7XG4gICAgdGhpcy5wYWNrYWdlTWFuYWdlciA9XG4gICAgICBvcHRpb25zLnBhY2thZ2VNYW5hZ2VyID8/IE5vZGVQYWNrYWdlTWFuYWdlci5ZQVJOX0NMQVNTSUM7XG4gICAgdGhpcy5lbnRyeXBvaW50ID0gb3B0aW9ucy5lbnRyeXBvaW50ID8/IFwibGliL2luZGV4LmpzXCI7XG4gICAgdGhpcy5sb2NrRmlsZSA9IGRldGVybWluZUxvY2tmaWxlKHRoaXMucGFja2FnZU1hbmFnZXIpO1xuXG4gICAgdGhpcy5wcm9qZWN0LmFubm90YXRlR2VuZXJhdGVkKGAvJHt0aGlzLmxvY2tGaWxlfWApO1xuXG4gICAgY29uc3Qge1xuICAgICAgbnBtQWNjZXNzLFxuICAgICAgbnBtUmVnaXN0cnksXG4gICAgICBucG1SZWdpc3RyeVVybCxcbiAgICAgIG5wbVRva2VuU2VjcmV0LFxuICAgICAgY29kZUFydGlmYWN0T3B0aW9ucyxcbiAgICAgIHNjb3BlZFBhY2thZ2VzT3B0aW9ucyxcbiAgICAgIG5wbVByb3ZlbmFuY2UsXG4gICAgfSA9IHRoaXMucGFyc2VOcG1PcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMubnBtQWNjZXNzID0gbnBtQWNjZXNzO1xuICAgIHRoaXMubnBtUmVnaXN0cnkgPSBucG1SZWdpc3RyeTtcbiAgICB0aGlzLm5wbVJlZ2lzdHJ5VXJsID0gbnBtUmVnaXN0cnlVcmw7XG4gICAgdGhpcy5ucG1Ub2tlblNlY3JldCA9IG5wbVRva2VuU2VjcmV0O1xuICAgIHRoaXMuY29kZUFydGlmYWN0T3B0aW9ucyA9IGNvZGVBcnRpZmFjdE9wdGlvbnM7XG4gICAgdGhpcy5zY29wZWRQYWNrYWdlc09wdGlvbnMgPSBzY29wZWRQYWNrYWdlc09wdGlvbnM7XG4gICAgdGhpcy5ucG1Qcm92ZW5hbmNlID0gbnBtUHJvdmVuYW5jZTtcblxuICAgIHRoaXMucHJvY2Vzc0RlcHMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9wcmV2ID0gdGhpcy5yZWFkUGFja2FnZUpzb24oKTtcblxuICAgIC8vIGVtcHR5IG9iamVjdHMgYXJlIGhlcmUgdG8gcHJlc2VydmUgb3JkZXIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5tYW5pZmVzdCA9IHtcbiAgICAgIG5hbWU6IHRoaXMucGFja2FnZU5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbixcbiAgICAgIHJlcG9zaXRvcnk6ICFvcHRpb25zLnJlcG9zaXRvcnlcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiB7XG4gICAgICAgICAgICB0eXBlOiBcImdpdFwiLFxuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnJlcG9zaXRvcnksXG4gICAgICAgICAgICBkaXJlY3Rvcnk6IG9wdGlvbnMucmVwb3NpdG9yeURpcmVjdG9yeSxcbiAgICAgICAgICB9LFxuICAgICAgYmluOiAoKSA9PiB0aGlzLnJlbmRlckJpbigpLFxuICAgICAgc2NyaXB0czogKCkgPT4gdGhpcy5yZW5kZXJTY3JpcHRzKCksXG4gICAgICBhdXRob3I6IHRoaXMucmVuZGVyQXV0aG9yKG9wdGlvbnMpLFxuICAgICAgZGV2RGVwZW5kZW5jaWVzOiB7fSxcbiAgICAgIHBlZXJEZXBlbmRlbmNpZXM6IHt9LFxuICAgICAgZGVwZW5kZW5jaWVzOiB7fSxcbiAgICAgIGJ1bmRsZWREZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgLi4udGhpcy5yZW5kZXJQYWNrYWdlUmVzb2x1dGlvbnMoKSxcbiAgICAgIGtleXdvcmRzOiAoKSA9PiB0aGlzLnJlbmRlcktleXdvcmRzKCksXG4gICAgICBlbmdpbmVzOiAoKSA9PiB0aGlzLnJlbmRlckVuZ2luZXMoKSxcbiAgICAgIG1haW46IHRoaXMuZW50cnlwb2ludCAhPT0gXCJcIiA/IHRoaXMuZW50cnlwb2ludCA6IHVuZGVmaW5lZCxcbiAgICAgIGxpY2Vuc2U6ICgpID0+IHRoaXMubGljZW5zZSA/PyBVTkxJQ0VOU0VELFxuICAgICAgaG9tZXBhZ2U6IG9wdGlvbnMuaG9tZXBhZ2UsXG4gICAgICBwdWJsaXNoQ29uZmlnOiAoKSA9PiB0aGlzLnJlbmRlclB1Ymxpc2hDb25maWcoKSxcbiAgICAgIHR5cGVzVmVyc2lvbnM6IHRoaXMuX3ByZXY/LnR5cGVzVmVyc2lvbnMsXG5cbiAgICAgIC8vIGluIHJlbGVhc2UgQ0kgYnVpbGRzIHdlIGJ1bXAgdGhlIHZlcnNpb24gYmVmb3JlIHdlIHJ1biBcImJ1aWxkXCIgc28gd2Ugd2FudFxuICAgICAgLy8gdG8gcHJlc2VydmUgdGhlIHZlcnNpb24gbnVtYmVyLiBvdGhlcndpc2UsIHdlIGFsd2F5cyBzZXQgaXQgdG8gMC4wLjBcbiAgICAgIHZlcnNpb246IHRoaXMuZGV0ZXJtaW5lVmVyc2lvbih0aGlzLl9wcmV2Py52ZXJzaW9uKSxcbiAgICAgIGJ1Z3M6XG4gICAgICAgIG9wdGlvbnMuYnVnc0VtYWlsIHx8IG9wdGlvbnMuYnVnc1VybFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBlbWFpbDogb3B0aW9ucy5idWdzRW1haWwsXG4gICAgICAgICAgICAgIHVybDogb3B0aW9ucy5idWdzVXJsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICAvLyBDb25maWd1cmUgWWFybiBCZXJyeSBpZiB1c2luZ1xuICAgIGlmIChcbiAgICAgIHRoaXMucGFja2FnZU1hbmFnZXIgPT09IE5vZGVQYWNrYWdlTWFuYWdlci5ZQVJOX0JFUlJZIHx8XG4gICAgICB0aGlzLnBhY2thZ2VNYW5hZ2VyID09PSBOb2RlUGFja2FnZU1hbmFnZXIuWUFSTjJcbiAgICApIHtcbiAgICAgIHRoaXMuY29uZmlndXJlWWFybkJlcnJ5KHByb2plY3QsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0YXNrcyBmb3Igc2NyaXB0cyBmcm9tIG9wdGlvbnMgKGlmIHNwZWNpZmllZClcbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIGZvciAoY29uc3QgW2NtZG5hbWUsIHNoZWxsXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNjcmlwdHMgPz8ge30pKSB7XG4gICAgICBwcm9qZWN0LmFkZFRhc2soY21kbmFtZSwgeyBleGVjOiBzaGVsbCB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbGUgPSBuZXcgSnNvbkZpbGUodGhpcywgXCJwYWNrYWdlLmpzb25cIiwge1xuICAgICAgb2JqOiB0aGlzLm1hbmlmZXN0LFxuICAgICAgcmVhZG9ubHk6IGZhbHNlLCAvLyB3ZSB3YW50IFwieWFybiBhZGRcIiB0byB3b3JrIGFuZCB3ZSBoYXZlIGFudGktdGFtcGVyXG4gICAgICBuZXdsaW5lOiB0cnVlLCAvLyBhbGwgcGFja2FnZSBtYW5hZ2VycyBwcmVmZXIgYSBuZXdsaW5lLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb2plbi9wcm9qZW4vaXNzdWVzLzIwNzZcbiAgICAgIGNvbW1pdHRlZDogdHJ1ZSwgLy8gbmVlZHMgdG8gYmUgY29tbWl0dGVkIHNvIHVzZXJzIGNhbiBpbnN0YWxsIHRoZSBkZXBlbmRlbmNpZXNcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkS2V5d29yZHMoLi4uKG9wdGlvbnMua2V5d29yZHMgPz8gW10pKTtcbiAgICB0aGlzLmFkZEJpbihvcHRpb25zLmJpbiA/PyB7fSk7XG5cbiAgICAvLyBhdXRvbWF0aWNhbGx5IGFkZCBhbGwgZXhlY3V0YWJsZSBmaWxlcyB1bmRlciBcImJpblwiXG4gICAgaWYgKG9wdGlvbnMuYXV0b0RldGVjdEJpbiA/PyB0cnVlKSB7XG4gICAgICB0aGlzLmF1dG9EaXNjb3ZlckJpbmFyaWVzKCk7XG4gICAgfVxuXG4gICAgLy8gbm9kZSB2ZXJzaW9uXG4gICAgdGhpcy5taW5Ob2RlVmVyc2lvbiA9IG9wdGlvbnMubWluTm9kZVZlcnNpb247XG4gICAgdGhpcy5tYXhOb2RlVmVyc2lvbiA9IG9wdGlvbnMubWF4Tm9kZVZlcnNpb247XG4gICAgdGhpcy5wbnBtVmVyc2lvbiA9IG9wdGlvbnMucG5wbVZlcnNpb24gPz8gXCI3XCI7XG4gICAgdGhpcy5hZGROb2RlRW5naW5lKCk7XG5cbiAgICB0aGlzLmFkZENvZGVBcnRpZmFjdExvZ2luU2NyaXB0KCk7XG5cbiAgICAvLyBsaWNlbnNlXG4gICAgaWYgKG9wdGlvbnMubGljZW5zZWQgPz8gdHJ1ZSkge1xuICAgICAgdGhpcy5saWNlbnNlID0gb3B0aW9ucy5saWNlbnNlID8/IFwiQXBhY2hlLTIuMFwiO1xuICAgIH1cblxuICAgIHRoaXMuaW5zdGFsbFRhc2sgPSBwcm9qZWN0LmFkZFRhc2soXCJpbnN0YWxsXCIsIHtcbiAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICBcIkluc3RhbGwgcHJvamVjdCBkZXBlbmRlbmNpZXMgYW5kIHVwZGF0ZSBsb2NrZmlsZSAobm9uLWZyb3plbilcIixcbiAgICAgIGV4ZWM6IHRoaXMuaW5zdGFsbEFuZFVwZGF0ZUxvY2tmaWxlQ29tbWFuZCxcbiAgICB9KTtcblxuICAgIHRoaXMuaW5zdGFsbENpVGFzayA9IHByb2plY3QuYWRkVGFzayhcImluc3RhbGw6Y2lcIiwge1xuICAgICAgZGVzY3JpcHRpb246IFwiSW5zdGFsbCBwcm9qZWN0IGRlcGVuZGVuY2llcyB1c2luZyBmcm96ZW4gbG9ja2ZpbGVcIixcbiAgICAgIGV4ZWM6IHRoaXMuaW5zdGFsbENvbW1hbmQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBub3JtYWwgZGVwZW5kZW5jaWVzLlxuICAgKlxuICAgKiBAcGFyYW0gZGVwcyBOYW1lcyBtb2R1bGVzIHRvIGluc3RhbGwuIEJ5IGRlZmF1bHQsIHRoZSB0aGUgZGVwZW5kZW5jeSB3aWxsXG4gICAqIGJlIGluc3RhbGxlZCBpbiB0aGUgbmV4dCBgbnB4IHByb2plbmAgcnVuIGFuZCB0aGUgdmVyc2lvbiB3aWxsIGJlIHJlY29yZGVkXG4gICAqIGluIHlvdXIgYHBhY2thZ2UuanNvbmAgZmlsZS4gWW91IGNhbiB1cGdyYWRlIG1hbnVhbGx5IG9yIHVzaW5nIGB5YXJuXG4gICAqIGFkZC91cGdyYWRlYC4gSWYgeW91IHdpc2ggdG8gc3BlY2lmeSBhIHZlcnNpb24gcmFuZ2UgdXNlIHRoaXMgc3ludGF4OlxuICAgKiBgbW9kdWxlQF43YC5cbiAgICovXG4gIHB1YmxpYyBhZGREZXBzKC4uLmRlcHM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgdGhpcy5wcm9qZWN0LmRlcHMuYWRkRGVwZW5kZW5jeShkZXAsIERlcGVuZGVuY3lUeXBlLlJVTlRJTUUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGRldmVsb3BtZW50L3Rlc3QgZGVwZW5kZW5jaWVzLlxuICAgKlxuICAgKiBAcGFyYW0gZGVwcyBOYW1lcyBtb2R1bGVzIHRvIGluc3RhbGwuIEJ5IGRlZmF1bHQsIHRoZSB0aGUgZGVwZW5kZW5jeSB3aWxsXG4gICAqIGJlIGluc3RhbGxlZCBpbiB0aGUgbmV4dCBgbnB4IHByb2plbmAgcnVuIGFuZCB0aGUgdmVyc2lvbiB3aWxsIGJlIHJlY29yZGVkXG4gICAqIGluIHlvdXIgYHBhY2thZ2UuanNvbmAgZmlsZS4gWW91IGNhbiB1cGdyYWRlIG1hbnVhbGx5IG9yIHVzaW5nIGB5YXJuXG4gICAqIGFkZC91cGdyYWRlYC4gSWYgeW91IHdpc2ggdG8gc3BlY2lmeSBhIHZlcnNpb24gcmFuZ2UgdXNlIHRoaXMgc3ludGF4OlxuICAgKiBgbW9kdWxlQF43YC5cbiAgICovXG4gIHB1YmxpYyBhZGREZXZEZXBzKC4uLmRlcHM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgdGhpcy5wcm9qZWN0LmRlcHMuYWRkRGVwZW5kZW5jeShkZXAsIERlcGVuZGVuY3lUeXBlLkJVSUxEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBwZWVyIGRlcGVuZGVuY2llcy5cbiAgICpcbiAgICogV2hlbiBhZGRpbmcgcGVlciBkZXBlbmRlbmNpZXMsIGEgZGV2RGVwZW5kZW5jeSB3aWxsIGFsc28gYmUgYWRkZWQgb24gdGhlXG4gICAqIHBpbm5lZCB2ZXJzaW9uIG9mIHRoZSBkZWNsYXJlZCBwZWVyLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgeW91IGFyZSB0ZXN0aW5nXG4gICAqIHlvdXIgY29kZSBhZ2FpbnN0IHRoZSBtaW5pbXVtIHZlcnNpb24gcmVxdWlyZWQgZnJvbSB5b3VyIGNvbnN1bWVycy5cbiAgICpcbiAgICogQHBhcmFtIGRlcHMgTmFtZXMgbW9kdWxlcyB0byBpbnN0YWxsLiBCeSBkZWZhdWx0LCB0aGUgdGhlIGRlcGVuZGVuY3kgd2lsbFxuICAgKiBiZSBpbnN0YWxsZWQgaW4gdGhlIG5leHQgYG5weCBwcm9qZW5gIHJ1biBhbmQgdGhlIHZlcnNpb24gd2lsbCBiZSByZWNvcmRlZFxuICAgKiBpbiB5b3VyIGBwYWNrYWdlLmpzb25gIGZpbGUuIFlvdSBjYW4gdXBncmFkZSBtYW51YWxseSBvciB1c2luZyBgeWFyblxuICAgKiBhZGQvdXBncmFkZWAuIElmIHlvdSB3aXNoIHRvIHNwZWNpZnkgYSB2ZXJzaW9uIHJhbmdlIHVzZSB0aGlzIHN5bnRheDpcbiAgICogYG1vZHVsZUBeN2AuXG4gICAqL1xuICBwdWJsaWMgYWRkUGVlckRlcHMoLi4uZGVwczogc3RyaW5nW10pIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoZGVwcykubGVuZ3RoICYmICF0aGlzLmFsbG93TGlicmFyeURlcGVuZGVuY2llcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgY2Fubm90IGFkZCBwZWVyIGRlcGVuZGVuY2llcyB0byBhbiBBUFAgcHJvamVjdDogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgICBkZXBzXG4gICAgICAgICkuam9pbihcIixcIil9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICB0aGlzLnByb2plY3QuZGVwcy5hZGREZXBlbmRlbmN5KGRlcCwgRGVwZW5kZW5jeVR5cGUuUEVFUik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYnVuZGxlZCBkZXBlbmRlbmNpZXMuXG4gICAqXG4gICAqIEJ1bmRsZWQgZGVwZW5kZW5jaWVzIHdpbGwgYmUgYWRkZWQgYXMgbm9ybWFsIGRlcGVuZGVuY2llcyBhcyB3ZWxsIGFzIHRvIHRoZVxuICAgKiBgYnVuZGxlZERlcGVuZGVuY2llc2Agc2VjdGlvbiBvZiB5b3VyIGBwYWNrYWdlLmpzb25gLlxuICAgKlxuICAgKiBAcGFyYW0gZGVwcyBOYW1lcyBtb2R1bGVzIHRvIGluc3RhbGwuIEJ5IGRlZmF1bHQsIHRoZSB0aGUgZGVwZW5kZW5jeSB3aWxsXG4gICAqIGJlIGluc3RhbGxlZCBpbiB0aGUgbmV4dCBgbnB4IHByb2plbmAgcnVuIGFuZCB0aGUgdmVyc2lvbiB3aWxsIGJlIHJlY29yZGVkXG4gICAqIGluIHlvdXIgYHBhY2thZ2UuanNvbmAgZmlsZS4gWW91IGNhbiB1cGdyYWRlIG1hbnVhbGx5IG9yIHVzaW5nIGB5YXJuXG4gICAqIGFkZC91cGdyYWRlYC4gSWYgeW91IHdpc2ggdG8gc3BlY2lmeSBhIHZlcnNpb24gcmFuZ2UgdXNlIHRoaXMgc3ludGF4OlxuICAgKiBgbW9kdWxlQF43YC5cbiAgICovXG4gIHB1YmxpYyBhZGRCdW5kbGVkRGVwcyguLi5kZXBzOiBzdHJpbmdbXSkge1xuICAgIGlmIChkZXBzLmxlbmd0aCAmJiAhdGhpcy5hbGxvd0xpYnJhcnlEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGNhbm5vdCBhZGQgYnVuZGxlZCBkZXBlbmRlbmNpZXMgdG8gYW4gQVBQIHByb2plY3Q6ICR7ZGVwcy5qb2luKFwiLFwiKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgIHRoaXMucHJvamVjdC5kZXBzLmFkZERlcGVuZGVuY3koZGVwLCBEZXBlbmRlbmN5VHlwZS5CVU5ETEVEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBgZW5naW5lc2AgcmVxdWlyZW1lbnQgdG8geW91ciBwYWNrYWdlLlxuICAgKiBAcGFyYW0gZW5naW5lIFRoZSBlbmdpbmUgKGUuZy4gYG5vZGVgKVxuICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgc2VtYW50aWMgdmVyc2lvbiByZXF1aXJlbWVudCAoZS5nLiBgXjEwYClcbiAgICovXG4gIHB1YmxpYyBhZGRFbmdpbmUoZW5naW5lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIHRoaXMuZW5naW5lc1tlbmdpbmVdID0gdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGtleXdvcmRzIHRvIHBhY2thZ2UuanNvbiAoZGVkdXBsaWNhdGVkKVxuICAgKiBAcGFyYW0ga2V5d29yZHMgVGhlIGtleXdvcmRzIHRvIGFkZFxuICAgKi9cbiAgcHVibGljIGFkZEtleXdvcmRzKC4uLmtleXdvcmRzOiBzdHJpbmdbXSkge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXl3b3Jkcykge1xuICAgICAgdGhpcy5rZXl3b3Jkcy5hZGQoayk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFkZEJpbihiaW5zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoYmlucykpIHtcbiAgICAgIHRoaXMuYmluW2tdID0gdjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbnBtIHBhY2thZ2UuanNvbiBzY3JpcHQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBzY3JpcHQgbmFtZVxuICAgKiBAcGFyYW0gY29tbWFuZCBUaGUgY29tbWFuZCB0byBleGVjdXRlXG4gICAqL1xuICBwdWJsaWMgc2V0U2NyaXB0KG5hbWU6IHN0cmluZywgY29tbWFuZDogc3RyaW5nKSB7XG4gICAgdGhpcy5zY3JpcHRzW25hbWVdID0gY29tbWFuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIG5wbSBzY3JpcHQgKGFsd2F5cyBzdWNjZXNzZnVsKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjcmlwdC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVTY3JpcHQobmFtZTogc3RyaW5nKSB7XG4gICAgLy8gbmVlZCB0byBrZWVwIHRyYWNrIGluIGNhc2UgdGhlcmUncyBhIHRhc2sgb2YgdGhlIHNhbWUgbmFtZVxuICAgIHRoaXMuc2NyaXB0c1RvQmVSZW1vdmVkLmFkZChuYW1lKTtcbiAgICBkZWxldGUgdGhpcy5zY3JpcHRzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiBhIHNjcmlwdCBieSB0aGUgZ2l2ZW4gbmFtZSBpcyBkZWZpbmVkLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2NyaXB0XG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcHJvamVjdC50YXNrcy50cnlGaW5kKG5hbWUpYFxuICAgKi9cbiAgcHVibGljIGhhc1NjcmlwdChuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0LnRhc2tzLnRyeUZpbmQobmFtZSkgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXJlY3RseSBzZXQgZmllbGRzIGluIGBwYWNrYWdlLmpzb25gLlxuICAgKiBAZXNjYXBlXG4gICAqIEBwYXJhbSBuYW1lIGZpZWxkIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIGZpZWxkIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgYWRkRmllbGQobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5tYW5pZmVzdFtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhY2thZ2UgdmVyc2lvbi5cbiAgICogQHBhcmFtIHZlcnNpb24gUGFja2FnZSB2ZXJzaW9uLlxuICAgKi9cbiAgcHVibGljIGFkZFZlcnNpb24odmVyc2lvbjogc3RyaW5nKSB7XG4gICAgdGhpcy5tYW5pZmVzdC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHJlc29sdXRpb25zIGZvciBkZXBlbmRlbmNpZXMgdG8gY2hhbmdlIHRoZSBub3JtYWxseSByZXNvbHZlZFxuICAgKiB2ZXJzaW9uIG9mIGEgZGVwZW5kZW5jeSB0byBzb21ldGhpbmcgZWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlc29sdXRpb25zIE5hbWVzIHJlc29sdXRpb25zIHRvIGJlIGFkZGVkLiBTcGVjaWZ5IGEgdmVyc2lvbiBvclxuICAgKiByYW5nZSB3aXRoIHRoaXMgc3ludGF4OlxuICAgKiBgbW9kdWxlQF43YFxuICAgKi9cbiAgcHVibGljIGFkZFBhY2thZ2VSZXNvbHV0aW9ucyguLi5yZXNvbHV0aW9uczogc3RyaW5nW10pIHtcbiAgICBmb3IgKGNvbnN0IHJlc29sdXRpb24gb2YgcmVzb2x1dGlvbnMpIHtcbiAgICAgIHRoaXMucHJvamVjdC5kZXBzLmFkZERlcGVuZGVuY3kocmVzb2x1dGlvbiwgRGVwZW5kZW5jeVR5cGUuT1ZFUlJJREUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21tYW5kIHRvIGV4ZWN1dGUgaW4gb3JkZXIgdG8gaW5zdGFsbCBhbGwgZGVwZW5kZW5jaWVzIChhbHdheXMgZnJvemVuKS5cbiAgICovXG4gIHB1YmxpYyBnZXQgaW5zdGFsbENvbW1hbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVySW5zdGFsbENvbW1hbmQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBgeWFybiBpbnN0YWxsYCBvciBgbnBtIGluc3RhbGxgIHdpdGggbG9ja2ZpbGUgdXBkYXRlIChub3QgZnJvemVuKVxuICAgKi9cbiAgcHVibGljIGdldCBpbnN0YWxsQW5kVXBkYXRlTG9ja2ZpbGVDb21tYW5kKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlckluc3RhbGxDb21tYW5kKGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgdGhlIGN1cnJlbnRseSBpbnN0YWxsZWQgdmVyc2lvbiBmb3IgYSBnaXZlbiBkZXBlbmRlbmN5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGZpcnN0IGxvb2sgdGhyb3VnaCB0aGUgY3VycmVudCBwcm9qZWN0J3MgZGVwZW5kZW5jaWVzLlxuICAgKiBJZiBmb3VuZCBhbmQgc2VtYW50aWNhbGx5IHZhbGlkIChub3QgJyonKSwgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAqIE90aGVyd2lzZSwgaXQgd2lsbCBmYWxsIGJhY2sgdG8gbG9jYXRpbmcgYSBgcGFja2FnZS5qc29uYCBtYW5pZmVzdCBmb3IgdGhlIGRlcGVuZGVuY3lcbiAgICogdGhyb3VnaCBub2RlJ3MgaW50ZXJuYWwgcmVzb2x1dGlvbiByZWFkaW5nIHRoZSB2ZXJzaW9uIGZyb20gdGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSBkZXBlbmRlbmN5TmFtZSBEZXBlbmRlbmN5IHRvIHJlc29sdmUgZm9yLlxuICAgKi9cbiAgcHVibGljIHRyeVJlc29sdmVEZXBlbmRlbmN5VmVyc2lvbihcbiAgICBkZXBlbmRlbmN5TmFtZTogc3RyaW5nXG4gICk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZyb21EZXBzID0gdGhpcy5wcm9qZWN0LmRlcHMudHJ5R2V0RGVwZW5kZW5jeShkZXBlbmRlbmN5TmFtZSk7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gc2VtdmVyLmNvZXJjZShmcm9tRGVwcz8udmVyc2lvbiwgeyBsb29zZTogdHJ1ZSB9KTtcbiAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uLmZvcm1hdCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge31cbiAgICByZXR1cm4gdHJ5UmVzb2x2ZURlcGVuZGVuY3lWZXJzaW9uKGRlcGVuZGVuY3lOYW1lLCB7XG4gICAgICBwYXRoczogW3RoaXMucHJvamVjdC5vdXRkaXJdLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpYyBzeW50aGVzaXplKCkge1xuICAgIHRoaXMuX3JlbmRlcmVkRGVwcyA9IHRoaXMucmVuZGVyRGVwZW5kZW5jaWVzKCk7XG4gICAgc3VwZXIuc3ludGhlc2l6ZSgpO1xuICB9XG5cbiAgcHVibGljIHBvc3RTeW50aGVzaXplKCkge1xuICAgIHN1cGVyLnBvc3RTeW50aGVzaXplKCk7XG5cbiAgICAvLyBvbmx5IHJ1biBcImluc3RhbGxcIiBpZiBwYWNrYWdlLmpzb24gaGFzIGNoYW5nZWQgb3IgaWYgd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gYG5vZGVfbW9kdWxlc2AgZGlyZWN0b3J5LlxuICAgIGlmIChcbiAgICAgIHRoaXMuZmlsZS5jaGFuZ2VkIHx8XG4gICAgICAhZXhpc3RzU3luYyhqb2luKHRoaXMucHJvamVjdC5vdXRkaXIsIFwibm9kZV9tb2R1bGVzXCIpKVxuICAgICkge1xuICAgICAgdGhpcy5pbnN0YWxsRGVwZW5kZW5jaWVzKCk7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBcIipcIiBkZXBzIGluIHBhY2thZ2UuanNvbiBhbmQgdXBkYXRlIGl0LiBpZiBpdCB3YXMgY2hhbmdlZCxcbiAgICAvLyBpbnN0YWxsIGRlcHMgYWdhaW4gc28gdGhhdCBsb2NrZmlsZSBpcyB1cGRhdGVkLlxuICAgIGlmICh0aGlzLnJlc29sdmVEZXBzQW5kV3JpdGVQYWNrYWdlSnNvbigpKSB7XG4gICAgICB0aGlzLmluc3RhbGxEZXBlbmRlbmNpZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbW1hbmQgd2hpY2ggZXhlY3V0ZXMgXCJwcm9qZW5cIi5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBwcm9qZWN0LnByb2plbkNvbW1hbmRgIGluc3RlYWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHByb2plbkNvbW1hbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdC5wcm9qZW5Db21tYW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHdlIGFyZSBydW5uaW5nIHdpdGhpbiBhIENJIGJ1aWxkLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgaXNBdXRvbWF0ZWRCdWlsZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNUcnV0aHkocHJvY2Vzcy5lbnYuQ0kpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXRlcm1pbmVWZXJzaW9uKGN1cnJWZXJzaW9uPzogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVsZWFzZUJ1aWxkKSB7XG4gICAgICByZXR1cm4gXCIwLjAuMFwiO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyVmVyc2lvbiA/PyBcIjAuMC4wXCI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBpcyBhIENJIHJlbGVhc2UgYnVpbGQuXG4gICAqL1xuICBwcml2YXRlIGdldCBpc1JlbGVhc2VCdWlsZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNUcnV0aHkocHJvY2Vzcy5lbnYuUkVMRUFTRSk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcHJpdmF0ZSBwYXJzZU5wbU9wdGlvbnMob3B0aW9uczogTm9kZVBhY2thZ2VPcHRpb25zKSB7XG4gICAgbGV0IG5wbVJlZ2lzdHJ5VXJsID0gb3B0aW9ucy5ucG1SZWdpc3RyeVVybDtcbiAgICBpZiAob3B0aW9ucy5ucG1SZWdpc3RyeSkge1xuICAgICAgaWYgKG5wbVJlZ2lzdHJ5VXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHVzZSB0aGUgZGVwcmVjYXRlZCBcIm5wbVJlZ2lzdHJ5XCIgdG9nZXRoZXIgd2l0aCBcIm5wbVJlZ2lzdHJ5VXJsXCIuIHBsZWFzZSB1c2UgXCJucG1SZWdpc3RyeVVybFwiIGluc3RlYWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBucG1SZWdpc3RyeVVybCA9IGBodHRwczovLyR7b3B0aW9ucy5ucG1SZWdpc3RyeX1gO1xuICAgIH1cblxuICAgIGNvbnN0IG5wbXIgPSBuZXcgVVJMKG5wbVJlZ2lzdHJ5VXJsID8/IERFRkFVTFRfTlBNX1JFR0lTVFJZX1VSTCk7XG4gICAgaWYgKCFucG1yIHx8ICFucG1yLmhvc3RuYW1lIHx8ICFucG1yLmhyZWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHVuYWJsZSB0byBkZXRlcm1pbmUgbnBtIHJlZ2lzdHJ5IGhvc3QgZnJvbSB1cmwgJHtucG1SZWdpc3RyeVVybH0uIElzIHRoaXMgcmVhbGx5IGEgVVJMP2BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbnBtQWNjZXNzID0gb3B0aW9ucy5ucG1BY2Nlc3MgPz8gZGVmYXVsdE5wbUFjY2Vzcyh0aGlzLnBhY2thZ2VOYW1lKTtcbiAgICBpZiAoIWlzU2NvcGVkKHRoaXMucGFja2FnZU5hbWUpICYmIG5wbUFjY2VzcyA9PT0gTnBtQWNjZXNzLlJFU1RSSUNURUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFwibnBtQWNjZXNzXCIgY2Fubm90IGJlIFJFU1RSSUNURUQgZm9yIG5vbi1zY29wZWQgbnBtIHBhY2thZ2UgXCIke3RoaXMucGFja2FnZU5hbWV9XCJgXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG5wbVByb3ZlbmFuY2UgPVxuICAgICAgb3B0aW9ucy5ucG1Qcm92ZW5hbmNlID8/IG5wbUFjY2VzcyA9PT0gTnBtQWNjZXNzLlBVQkxJQztcbiAgICBpZiAobnBtUHJvdmVuYW5jZSAmJiBucG1BY2Nlc3MgIT09IE5wbUFjY2Vzcy5QVUJMSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFwibnBtUHJvdmVuYW5jZVwiIGNhbiBvbmx5IGJlIGVuYWJsZWQgZm9yIHB1YmxpYyBwYWNrYWdlc2BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNBd3NDb2RlQXJ0aWZhY3QgPSBpc0F3c0NvZGVBcnRpZmFjdFJlZ2lzdHJ5KG5wbVJlZ2lzdHJ5VXJsKTtcbiAgICBjb25zdCBoYXNTY29wZWRQYWNrYWdlID1cbiAgICAgIG9wdGlvbnMuc2NvcGVkUGFja2FnZXNPcHRpb25zICYmXG4gICAgICBvcHRpb25zLnNjb3BlZFBhY2thZ2VzT3B0aW9ucy5sZW5ndGggIT09IDA7XG5cbiAgICBpZiAoaXNBd3NDb2RlQXJ0aWZhY3QpIHtcbiAgICAgIGlmIChvcHRpb25zLm5wbVRva2VuU2VjcmV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnXCJucG1Ub2tlblNlY3JldFwiIG11c3Qgbm90IGJlIHNwZWNpZmllZCB3aGVuIHB1Ymxpc2hpbmcgQVdTIENvZGVBcnRpZmFjdC4nXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBvcHRpb25zLmNvZGVBcnRpZmFjdE9wdGlvbnM/LmF1dGhQcm92aWRlciA9PT1cbiAgICAgICAgQ29kZUFydGlmYWN0QXV0aFByb3ZpZGVyLkdJVEhVQl9PSURDXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9wdGlvbnMuY29kZUFydGlmYWN0T3B0aW9ucy5hY2Nlc3NLZXlJZFNlY3JldCB8fFxuICAgICAgICAgIG9wdGlvbnMuY29kZUFydGlmYWN0T3B0aW9ucy5zZWNyZXRBY2Nlc3NLZXlTZWNyZXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJhY2Nlc3MgYW5kIHNlY3JldCBrZXkgcGFpciBzaG91bGQgbm90IGJlIHByb3ZpZGVkIHdoZW4gdXNpbmcgR0lUSFVCX09JREMgYXV0aCBwcm92aWRlciBmb3IgQVdTIENvZGVBcnRpZmFjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5jb2RlQXJ0aWZhY3RPcHRpb25zLnJvbGVUb0Fzc3VtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdcInJvbGVUb0Fzc3VtZVwiIHByb3BlcnR5IGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgR0lUSFVCX09JREMgZm9yIEFXUyBDb2RlQXJ0aWZhY3Qgb3B0aW9ucydcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMuY29kZUFydGlmYWN0T3B0aW9ucz8uYWNjZXNzS2V5SWRTZWNyZXQgfHxcbiAgICAgICAgICBvcHRpb25zLmNvZGVBcnRpZmFjdE9wdGlvbnM/LnNlY3JldEFjY2Vzc0tleVNlY3JldCB8fFxuICAgICAgICAgIG9wdGlvbnMuY29kZUFydGlmYWN0T3B0aW9ucz8ucm9sZVRvQXNzdW1lKSAmJlxuICAgICAgICAhaGFzU2NvcGVkUGFja2FnZVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcImNvZGVBcnRpZmFjdE9wdGlvbnMgbXVzdCBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIHB1Ymxpc2hpbmcgQVdTIENvZGVBcnRpZmFjdCBvciB1c2VkIGluIHNjb3BlZCBwYWNrYWdlcy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IGRlZmF1bHRzIGZvciBBV1MgQ29kZUFydGlmYWN0XG4gICAgbGV0IGNvZGVBcnRpZmFjdE9wdGlvbnM6IENvZGVBcnRpZmFjdE9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgaWYgKGlzQXdzQ29kZUFydGlmYWN0IHx8IGhhc1Njb3BlZFBhY2thZ2UpIHtcbiAgICAgIGNvbnN0IGF1dGhQcm92aWRlciA9XG4gICAgICAgIG9wdGlvbnMuY29kZUFydGlmYWN0T3B0aW9ucz8uYXV0aFByb3ZpZGVyID8/XG4gICAgICAgIENvZGVBcnRpZmFjdEF1dGhQcm92aWRlci5BQ0NFU1NfQU5EX1NFQ1JFVF9LRVlfUEFJUjtcbiAgICAgIGNvbnN0IGlzQWNjZXNzU2VjcmV0S2V5UGFpckF1dGggPVxuICAgICAgICBhdXRoUHJvdmlkZXIgPT09IENvZGVBcnRpZmFjdEF1dGhQcm92aWRlci5BQ0NFU1NfQU5EX1NFQ1JFVF9LRVlfUEFJUjtcbiAgICAgIGNvZGVBcnRpZmFjdE9wdGlvbnMgPSB7XG4gICAgICAgIGF1dGhQcm92aWRlcixcbiAgICAgICAgYWNjZXNzS2V5SWRTZWNyZXQ6XG4gICAgICAgICAgb3B0aW9ucy5jb2RlQXJ0aWZhY3RPcHRpb25zPy5hY2Nlc3NLZXlJZFNlY3JldCA/P1xuICAgICAgICAgIChpc0FjY2Vzc1NlY3JldEtleVBhaXJBdXRoID8gXCJBV1NfQUNDRVNTX0tFWV9JRFwiIDogdW5kZWZpbmVkKSxcbiAgICAgICAgc2VjcmV0QWNjZXNzS2V5U2VjcmV0OlxuICAgICAgICAgIG9wdGlvbnMuY29kZUFydGlmYWN0T3B0aW9ucz8uc2VjcmV0QWNjZXNzS2V5U2VjcmV0ID8/XG4gICAgICAgICAgKGlzQWNjZXNzU2VjcmV0S2V5UGFpckF1dGggPyBcIkFXU19TRUNSRVRfQUNDRVNTX0tFWVwiIDogdW5kZWZpbmVkKSxcbiAgICAgICAgcm9sZVRvQXNzdW1lOiBvcHRpb25zLmNvZGVBcnRpZmFjdE9wdGlvbnM/LnJvbGVUb0Fzc3VtZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5wbUFjY2VzcyxcbiAgICAgIG5wbVJlZ2lzdHJ5OiBucG1yLmhvc3RuYW1lICsgdGhpcy5yZW5kZXJOcG1SZWdpc3RyeVBhdGgobnBtci5wYXRobmFtZSEpLFxuICAgICAgbnBtUmVnaXN0cnlVcmw6IG5wbXIuaHJlZixcbiAgICAgIG5wbVRva2VuU2VjcmV0OiBkZWZhdWx0TnBtVG9rZW4ob3B0aW9ucy5ucG1Ub2tlblNlY3JldCwgbnBtci5ob3N0bmFtZSksXG4gICAgICBjb2RlQXJ0aWZhY3RPcHRpb25zLFxuICAgICAgc2NvcGVkUGFja2FnZXNPcHRpb25zOiB0aGlzLnBhcnNlU2NvcGVkUGFja2FnZXNPcHRpb25zKFxuICAgICAgICBvcHRpb25zLnNjb3BlZFBhY2thZ2VzT3B0aW9uc1xuICAgICAgKSxcbiAgICAgIG5wbVByb3ZlbmFuY2UsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VTY29wZWRQYWNrYWdlc09wdGlvbnMoXG4gICAgc2NvcGVkUGFja2FnZXNPcHRpb25zPzogU2NvcGVkUGFja2FnZXNPcHRpb25zW11cbiAgKTogU2NvcGVkUGFja2FnZXNPcHRpb25zW10gfCB1bmRlZmluZWQge1xuICAgIGlmICghc2NvcGVkUGFja2FnZXNPcHRpb25zKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZWRQYWNrYWdlc09wdGlvbnMubWFwKChvcHRpb24pOiBTY29wZWRQYWNrYWdlc09wdGlvbnMgPT4ge1xuICAgICAgaWYgKCFpc1Njb3BlZChvcHRpb24uc2NvcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgU2NvcGUgbXVzdCBzdGFydCB3aXRoIFwiQFwiIGluIG9wdGlvbnMsIGZvdW5kICR7b3B0aW9uLnNjb3BlfWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0F3c0NvZGVBcnRpZmFjdFJlZ2lzdHJ5KG9wdGlvbi5yZWdpc3RyeVVybCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBPbmx5IEFXUyBDb2RlIGFydGlmYWN0IHNjb3BlZCByZWdpc3RyeSBpcyBzdXBwb3J0ZWQgZm9yIG5vdywgZm91bmQgJHtvcHRpb24ucmVnaXN0cnlVcmx9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IFNjb3BlZFBhY2thZ2VzT3B0aW9ucyA9IHtcbiAgICAgICAgcmVnaXN0cnlVcmw6IG9wdGlvbi5yZWdpc3RyeVVybCxcbiAgICAgICAgc2NvcGU6IG9wdGlvbi5zY29wZSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFkZENvZGVBcnRpZmFjdExvZ2luU2NyaXB0KCkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLnNjb3BlZFBhY2thZ2VzT3B0aW9ucyB8fFxuICAgICAgdGhpcy5zY29wZWRQYWNrYWdlc09wdGlvbnMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9qZWN0LmFkZFRhc2soXCJjYTpsb2dpblwiLCB7XG4gICAgICByZXF1aXJlZEVudjogW1wiQVdTX0FDQ0VTU19LRVlfSURcIiwgXCJBV1NfU0VDUkVUX0FDQ0VTU19LRVlcIl0sXG4gICAgICBzdGVwczogW1xuICAgICAgICB7IGV4ZWM6IFwid2hpY2ggYXdzXCIgfSwgLy8gY2hlY2sgdGhhdCBBV1MgQ0xJIGlzIGluc3RhbGxlZFxuICAgICAgICAuLi50aGlzLnNjb3BlZFBhY2thZ2VzT3B0aW9ucy5tYXAoKHNjb3BlZFBhY2thZ2VzT3B0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyByZWdpc3RyeVVybCwgc2NvcGUgfSA9IHNjb3BlZFBhY2thZ2VzT3B0aW9uO1xuICAgICAgICAgIGNvbnN0IHsgZG9tYWluLCByZWdpb24sIGFjY291bnRJZCwgcmVnaXN0cnkgfSA9XG4gICAgICAgICAgICBleHRyYWN0Q29kZUFydGlmYWN0RGV0YWlscyhyZWdpc3RyeVVybCk7XG4gICAgICAgICAgLy8gcmVmZXJlbmNlOiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY29kZWFydGlmYWN0L2xhdGVzdC91Zy9ucG0tYXV0aC5odG1sXG4gICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgICAgICAgICBgbnBtIGNvbmZpZyBzZXQgJHtzY29wZX06cmVnaXN0cnkgJHtyZWdpc3RyeVVybH1gLFxuICAgICAgICAgICAgYENPREVBUlRJRkFDVF9BVVRIX1RPS0VOPSQoYXdzIGNvZGVhcnRpZmFjdCBnZXQtYXV0aG9yaXphdGlvbi10b2tlbiAtLWRvbWFpbiAke2RvbWFpbn0gLS1yZWdpb24gJHtyZWdpb259IC0tZG9tYWluLW93bmVyICR7YWNjb3VudElkfSAtLXF1ZXJ5IGF1dGhvcml6YXRpb25Ub2tlbiAtLW91dHB1dCB0ZXh0KWAsXG4gICAgICAgICAgICBgbnBtIGNvbmZpZyBzZXQgLy8ke3JlZ2lzdHJ5fTpfYXV0aFRva2VuPSRDT0RFQVJUSUZBQ1RfQVVUSF9UT0tFTmAsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoIXRoaXMubWluTm9kZVZlcnNpb24gfHwgc2VtdmVyLm1ham9yKHRoaXMubWluTm9kZVZlcnNpb24pIDw9IDE2KVxuICAgICAgICAgICAgY29tbWFuZHMucHVzaChgbnBtIGNvbmZpZyBzZXQgLy8ke3JlZ2lzdHJ5fTphbHdheXMtYXV0aD10cnVlYCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4ZWM6IGNvbW1hbmRzLmpvaW4oXCI7IFwiKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFkZE5vZGVFbmdpbmUoKSB7XG4gICAgaWYgKCF0aGlzLm1pbk5vZGVWZXJzaW9uICYmICF0aGlzLm1heE5vZGVWZXJzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG5vZGVWZXJzaW9uID0gXCJcIjtcbiAgICBpZiAodGhpcy5taW5Ob2RlVmVyc2lvbikge1xuICAgICAgbm9kZVZlcnNpb24gKz0gYD49ICR7dGhpcy5taW5Ob2RlVmVyc2lvbn1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhOb2RlVmVyc2lvbikge1xuICAgICAgbm9kZVZlcnNpb24gKz0gYCA8PSAke3RoaXMubWF4Tm9kZVZlcnNpb259YDtcbiAgICB9XG4gICAgdGhpcy5hZGRFbmdpbmUoXCJub2RlXCIsIG5vZGVWZXJzaW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyTnBtUmVnaXN0cnlQYXRoKHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgaWYgKCFwYXRoIHx8IHBhdGggPT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckluc3RhbGxDb21tYW5kKGZyb3plbjogYm9vbGVhbikge1xuICAgIHN3aXRjaCAodGhpcy5wYWNrYWdlTWFuYWdlcikge1xuICAgICAgY2FzZSBOb2RlUGFja2FnZU1hbmFnZXIuWUFSTjpcbiAgICAgIGNhc2UgTm9kZVBhY2thZ2VNYW5hZ2VyLllBUk5fQ0xBU1NJQzpcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcInlhcm4gaW5zdGFsbFwiLFxuICAgICAgICAgIFwiLS1jaGVjay1maWxlc1wiLCAvLyBlbnN1cmUgYWxsIG1vZHVsZXMgZXhpc3QgKGVzcGVjaWFsbHkgcHJvamVuIHdoaWNoIHdhcyBqdXN0IHJlbW92ZWQpLlxuICAgICAgICAgIC4uLihmcm96ZW4gPyBbXCItLWZyb3plbi1sb2NrZmlsZVwiXSA6IFtdKSxcbiAgICAgICAgXS5qb2luKFwiIFwiKTtcbiAgICAgIGNhc2UgTm9kZVBhY2thZ2VNYW5hZ2VyLllBUk4yOlxuICAgICAgY2FzZSBOb2RlUGFja2FnZU1hbmFnZXIuWUFSTl9CRVJSWTpcbiAgICAgICAgcmV0dXJuIFtcInlhcm4gaW5zdGFsbFwiLCAuLi4oZnJvemVuID8gW1wiLS1pbW11dGFibGVcIl0gOiBbXSldLmpvaW4oXCIgXCIpO1xuICAgICAgY2FzZSBOb2RlUGFja2FnZU1hbmFnZXIuTlBNOlxuICAgICAgICByZXR1cm4gZnJvemVuID8gXCJucG0gY2lcIiA6IFwibnBtIGluc3RhbGxcIjtcbiAgICAgIGNhc2UgTm9kZVBhY2thZ2VNYW5hZ2VyLlBOUE06XG4gICAgICAgIHJldHVybiBmcm96ZW5cbiAgICAgICAgICA/IFwicG5wbSBpIC0tZnJvemVuLWxvY2tmaWxlXCJcbiAgICAgICAgICA6IFwicG5wbSBpIC0tbm8tZnJvemVuLWxvY2tmaWxlXCI7XG4gICAgICBjYXNlIE5vZGVQYWNrYWdlTWFuYWdlci5CVU46XG4gICAgICAgIHJldHVybiBbXCJidW4gaW5zdGFsbFwiLCAuLi4oZnJvemVuID8gW1wiLS1mcm96ZW4tbG9ja2ZpbGVcIl0gOiBbXSldLmpvaW4oXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHBhY2thZ2UgbWFuYWdlciAke3RoaXMucGFja2FnZU1hbmFnZXJ9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzRGVwcyhvcHRpb25zOiBOb2RlUGFja2FnZU9wdGlvbnMpIHtcbiAgICB0aGlzLmFkZERlcHMoLi4uKG9wdGlvbnMuZGVwcyA/PyBbXSkpO1xuICAgIHRoaXMuYWRkRGV2RGVwcyguLi4ob3B0aW9ucy5kZXZEZXBzID8/IFtdKSk7XG4gICAgdGhpcy5hZGRQZWVyRGVwcyguLi4ob3B0aW9ucy5wZWVyRGVwcyA/PyBbXSkpO1xuICAgIHRoaXMuYWRkQnVuZGxlZERlcHMoLi4uKG9wdGlvbnMuYnVuZGxlZERlcHMgPz8gW10pKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyRGVwZW5kZW5jaWVzKCk6IE5wbURlcGVuZGVuY2llcyB7XG4gICAgY29uc3QgZGV2RGVwZW5kZW5jaWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgY29uc3QgcGVlckRlcGVuZGVuY2llczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGNvbnN0IGRlcGVuZGVuY2llczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGNvbnN0IGJ1bmRsZWREZXBlbmRlbmNpZXMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgLy8gc3ludGhldGljIGRlcGVuZGVuY2llczogYWRkIGEgcGlubmVkIGJ1aWxkIGRlcGVuZGVuY3kgdG8gZW5zdXJlIHdlIGFyZVxuICAgIC8vIHRlc3RpbmcgYWdhaW5zdCB0aGUgbWluaW11bSByZXF1aXJlbWVudCBvZiB0aGUgcGVlci5cbiAgICBpZiAodGhpcy5wZWVyRGVwZW5kZW5jeU9wdGlvbnMucGlubmVkRGV2RGVwZW5kZW5jeSkge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgdGhpcy5wcm9qZWN0LmRlcHMuYWxsLmZpbHRlcihcbiAgICAgICAgKGQpID0+IGQudHlwZSA9PT0gRGVwZW5kZW5jeVR5cGUuUEVFUlxuICAgICAgKSkge1xuICAgICAgICBsZXQgcmVxID0gZGVwLm5hbWU7XG5cbiAgICAgICAgLy8gU2tpcCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBydW50aW1lIGRlcGVuZGVuY3kgb24gdGhpcyBwZWVyIGFuZCBubyBidWlsZCBkZXBlbmRlbmN5IHlldC5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBidWlsZCBkZXAgYWxyZWFkeSwgd2UgbmVlZCB0byBvdmVycmlkZSBpdHMgdmVyc2lvbi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMucHJvamVjdC5kZXBzLnRyeUdldERlcGVuZGVuY3koXG4gICAgICAgICAgICBkZXAubmFtZSxcbiAgICAgICAgICAgIERlcGVuZGVuY3lUeXBlLlJVTlRJTUVcbiAgICAgICAgICApICYmXG4gICAgICAgICAgIXRoaXMucHJvamVjdC5kZXBzLnRyeUdldERlcGVuZGVuY3koZGVwLm5hbWUsIERlcGVuZGVuY3lUeXBlLkJVSUxEKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXAudmVyc2lvbikge1xuICAgICAgICAgIGNvbnN0IHZlciA9IG1pblZlcnNpb24oZGVwLnZlcnNpb24pO1xuICAgICAgICAgIGlmICghdmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGB1bmFibGUgdG8gZGV0ZXJtaW5lIG1pbmltdW0gc2VtdmVyIGZvciBwZWVyIGRlcGVuZGVuY3kgJHtkZXAubmFtZX1AJHtkZXAudmVyc2lvbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcSArPSBcIkBcIiArIHZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZERldkRlcHMocmVxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLnByb2plY3QuZGVwcy5hbGwpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gZGVwLnZlcnNpb24gPz8gXCIqXCI7XG4gICAgICBsZXQgbmFtZSA9IGRlcC5uYW1lO1xuXG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICAgICAgY29uc3QgbG9jYWxEZXBlbmRlbmN5UGF0aCA9IG5hbWUuc3Vic3RyaW5nKDUpO1xuICAgICAgICBjb25zdCBkZXBQYWNrYWdlSnNvbiA9IHJlc29sdmUoXG4gICAgICAgICAgdGhpcy5wcm9qZWN0Lm91dGRpcixcbiAgICAgICAgICBsb2NhbERlcGVuZGVuY3lQYXRoLFxuICAgICAgICAgIFwicGFja2FnZS5qc29uXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcGtnRmlsZSA9IHJlYWRGaWxlU3luYyhkZXBQYWNrYWdlSnNvbiwgXCJ1dGY4XCIpO1xuICAgICAgICBjb25zdCBwa2cgPSBKU09OLnBhcnNlKHBrZ0ZpbGUpO1xuICAgICAgICB2ZXJzaW9uID0gbG9jYWxEZXBlbmRlbmN5UGF0aDtcbiAgICAgICAgbmFtZSA9IHBrZy5uYW1lO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGRlcC50eXBlKSB7XG4gICAgICAgIGNhc2UgRGVwZW5kZW5jeVR5cGUuQlVORExFRDpcbiAgICAgICAgICBidW5kbGVkRGVwZW5kZW5jaWVzLnB1c2gobmFtZSk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnByb2plY3QuZGVwcy5hbGwuZmluZChcbiAgICAgICAgICAgICAgKGQpID0+IGQubmFtZSA9PT0gbmFtZSAmJiBkLnR5cGUgPT09IERlcGVuZGVuY3lUeXBlLlBFRVJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYHVuYWJsZSB0byBidW5kbGUgXCIke25hbWV9XCIuIGl0IGNhbm5vdCBhcHBlYXIgYXMgYSBwZWVyIGRlcGVuZGVuY3lgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFsc28gYWRkIGFzIGEgcnVudGltZSBkZXBlbmRlbmN5XG4gICAgICAgICAgZGVwZW5kZW5jaWVzW25hbWVdID0gdmVyc2lvbjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIERlcGVuZGVuY3lUeXBlLlBFRVI6XG4gICAgICAgICAgcGVlckRlcGVuZGVuY2llc1tuYW1lXSA9IHZlcnNpb247XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBEZXBlbmRlbmN5VHlwZS5SVU5USU1FOlxuICAgICAgICAgIGRlcGVuZGVuY2llc1tuYW1lXSA9IHZlcnNpb247XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBEZXBlbmRlbmN5VHlwZS5URVNUOlxuICAgICAgICBjYXNlIERlcGVuZGVuY3lUeXBlLkRFVkVOVjpcbiAgICAgICAgY2FzZSBEZXBlbmRlbmN5VHlwZS5CVUlMRDpcbiAgICAgICAgICBkZXZEZXBlbmRlbmNpZXNbbmFtZV0gPSB2ZXJzaW9uO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybnMgYSBsYXp5IHZhbHVlIHRvIG5vcm1hbGl6ZSBkdXJpbmcgc3ludGhlc2lzXG4gICAgY29uc3Qgbm9ybWFsaXplID0gKG9iajogYW55KSA9PiAoKSA9PiBzb3J0ZWQob2JqKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgbWFuaWZlc3Qgd2UgYXJlIGFib3V0IHRvIHNhdmUgaW50byBgcGFja2FnZS5qc29uYFxuICAgIHRoaXMubWFuaWZlc3QuZGV2RGVwZW5kZW5jaWVzID0gbm9ybWFsaXplKGRldkRlcGVuZGVuY2llcyk7XG4gICAgdGhpcy5tYW5pZmVzdC5wZWVyRGVwZW5kZW5jaWVzID0gbm9ybWFsaXplKHBlZXJEZXBlbmRlbmNpZXMpO1xuICAgIHRoaXMubWFuaWZlc3QuZGVwZW5kZW5jaWVzID0gbm9ybWFsaXplKGRlcGVuZGVuY2llcyk7XG4gICAgdGhpcy5tYW5pZmVzdC5idW5kbGVkRGVwZW5kZW5jaWVzID0gc29ydGVkKGJ1bmRsZWREZXBlbmRlbmNpZXMpO1xuXG4gICAgLy8gbm90aGluZyBmdXJ0aGVyIHRvIGRvIGlmIHBhY2thZ2UuanNvbiBmaWxlIGRvZXMgbm90IGV4aXN0XG4gICAgaWYgKCF0aGlzLl9wcmV2KSB7XG4gICAgICByZXR1cm4geyBkZXZEZXBlbmRlbmNpZXMsIHBlZXJEZXBlbmRlbmNpZXMsIGRlcGVuZGVuY2llcyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWREZXBzID0gKFxuICAgICAgdXNlcjogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICAgIGN1cnJlbnQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgICkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdXNlclZlcnNpb25dIG9mIE9iamVjdC5lbnRyaWVzKHVzZXIpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uID0gY3VycmVudFtuYW1lXTtcblxuICAgICAgICAvLyByZXNwZWN0IHVzZXIgdmVyc2lvbiBpZiBpdCdzIG5vdCAnKicgb3IgaWYgY3VycmVudCB2ZXJzaW9uIGlzIHVuZGVmaW5lZFxuICAgICAgICBpZiAodXNlclZlcnNpb24gIT09IFwiKlwiIHx8ICFjdXJyZW50VmVyc2lvbiB8fCBjdXJyZW50VmVyc2lvbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lbW9pemUgY3VycmVudCB2ZXJzaW9uIGluIG1lbW9yeSBzbyBpdCBpcyBwcmVzZXJ2ZWQgd2hlbiBzYXZpbmdcbiAgICAgICAgdXNlcltuYW1lXSA9IGN1cnJlbnRWZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICAvLyByZXBvcnQgcmVtb3ZhbHNcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhjdXJyZW50ID8/IHt9KSkge1xuICAgICAgICBpZiAoIXVzZXJbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLnByb2plY3QubG9nZ2VyLnZlcmJvc2UoYCR7bmFtZX06IHJlbW92ZWRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZWFkRGVwcyhkZXZEZXBlbmRlbmNpZXMsIHRoaXMuX3ByZXYuZGV2RGVwZW5kZW5jaWVzKTtcbiAgICByZWFkRGVwcyhkZXBlbmRlbmNpZXMsIHRoaXMuX3ByZXYuZGVwZW5kZW5jaWVzKTtcbiAgICByZWFkRGVwcyhwZWVyRGVwZW5kZW5jaWVzLCB0aGlzLl9wcmV2LnBlZXJEZXBlbmRlbmNpZXMpO1xuXG4gICAgcmV0dXJuIHsgZGV2RGVwZW5kZW5jaWVzLCBkZXBlbmRlbmNpZXMsIHBlZXJEZXBlbmRlbmNpZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhbnkgZGVwcyB0aGF0IGRvIG5vdCBoYXZlIGEgc3BlY2lmaWVkIHZlcnNpb24gKGUuZy4gYCpgKSBhbmRcbiAgICogdXBkYXRlIGBwYWNrYWdlLmpzb25gIGlmIG5lZWRlZC5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHBhY2thZ2UuanNvbiB3YXMgdXBkYXRlZCBvciBgZmFsc2VgIGlmIG5vdC5cbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZURlcHNBbmRXcml0ZVBhY2thZ2VKc29uKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG91dGRpciA9IHRoaXMucHJvamVjdC5vdXRkaXI7XG4gICAgY29uc3Qgcm9vdFBhY2thZ2VKc29uID0gam9pbihvdXRkaXIsIFwicGFja2FnZS5qc29uXCIpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSByZWFkRmlsZVN5bmMocm9vdFBhY2thZ2VKc29uLCBcInV0ZjhcIik7XG4gICAgY29uc3QgcGtnID0gSlNPTi5wYXJzZShvcmlnaW5hbCk7XG5cbiAgICBjb25zdCByZXNvbHZlRGVwcyA9IChcbiAgICAgIGN1cnJlbnQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9LFxuICAgICAgdXNlcjogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgICkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICBjdXJyZW50ID0gY3VycmVudCA/PyB7fTtcbiAgICAgIHVzZXIgPSB1c2VyID8/IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCBjdXJyZW50RGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXModXNlcikpIHtcbiAgICAgICAgLy8gZmluZCBhY3R1YWwgdmVyc2lvbiBmcm9tIG5vZGVfbW9kdWxlc1xuICAgICAgICBsZXQgZGVzaXJlZFZlcnNpb24gPSBjdXJyZW50RGVmaW5pdGlvbjtcblxuICAgICAgICBpZiAoY3VycmVudERlZmluaXRpb24gPT09IFwiKlwiKSB7XG4gICAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IHdlIGRvbid0IGhhdmUgdGhlIHZlcnNpb24gaW4gcHJvamVjdCBgZGVwc2AsXG4gICAgICAgICAgLy8gc28gc2tpcCBzdHJhaWdodCB0byBjaGVja2luZyBtYW5pZmVzdC5cbiAgICAgICAgICBjb25zdCByZXNvbHZlZFZlcnNpb24gPSB0cnlSZXNvbHZlRGVwZW5kZW5jeVZlcnNpb24obmFtZSwge1xuICAgICAgICAgICAgcGF0aHM6IFt0aGlzLnByb2plY3Qub3V0ZGlyXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXJlc29sdmVkVmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0LmxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICBgdW5hYmxlIHRvIHJlc29sdmUgdmVyc2lvbiBmb3IgJHtuYW1lfSBmcm9tIGluc3RhbGxlZCBtb2R1bGVzYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXNpcmVkVmVyc2lvbiA9IGBeJHtyZXNvbHZlZFZlcnNpb259YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGVmaW5pdGlvbiAhPT0gZGVzaXJlZFZlcnNpb24pIHtcbiAgICAgICAgICB0aGlzLnByb2plY3QubG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICBgJHtuYW1lfTogJHtjdXJyZW50RGVmaW5pdGlvbn0gPT4gJHtkZXNpcmVkVmVyc2lvbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IGRlc2lyZWRWZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmludCByZW1vdmVkIHBhY2thZ2VzXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoY3VycmVudCkpIHtcbiAgICAgICAgaWYgKCFyZXN1bHRbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLnByb2plY3QubG9nZ2VyLnZlcmJvc2UoYCR7bmFtZX0gcmVtb3ZlZGApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbmRlcmVkID0gdGhpcy5fcmVuZGVyZWREZXBzO1xuICAgIGlmICghcmVuZGVyZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFzc2VydGlvbiBmYWlsZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZGVwcyA9IHJlc29sdmVEZXBzKHBrZy5kZXBlbmRlbmNpZXMsIHJlbmRlcmVkLmRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgZGV2RGVwcyA9IHJlc29sdmVEZXBzKHBrZy5kZXZEZXBlbmRlbmNpZXMsIHJlbmRlcmVkLmRldkRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgcGVlckRlcHMgPSByZXNvbHZlRGVwcyhcbiAgICAgIHBrZy5wZWVyRGVwZW5kZW5jaWVzLFxuICAgICAgcmVuZGVyZWQucGVlckRlcGVuZGVuY2llc1xuICAgICk7XG5cbiAgICBpZiAodGhpcy5wZWVyRGVwZW5kZW5jeU9wdGlvbnMucGlubmVkRGV2RGVwZW5kZW5jeSkge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXMocGVlckRlcHMpKSB7XG4gICAgICAgIC8vIFNraXAgaWYgd2UgYWxyZWFkeSBoYXZlIGEgcnVudGltZSBkZXBlbmRlbmN5IG9uIHRoaXMgcGVlclxuICAgICAgICAvLyBvciBpZiBkZXZEZXBlbmRlbmN5IHZlcnNpb24gaXMgYWxyZWFkeSBzZXQuXG4gICAgICAgIC8vIFJlbGllcyBvbiB0aGUgXCIqXCIgZGV2RGVwZW5kZW5jeSBhZGRlZCBpbiB0aGUgcHJlc3ludGggc3RlcFxuICAgICAgICBpZiAoZGVwc1tuYW1lXSB8fCByZW5kZXJlZC5kZXZEZXBlbmRlbmNpZXNbbmFtZV0gIT09IFwiKlwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlIHZlcnNpb24gYW5kIHBpbiBhcyBkZXYgZGVwZW5kZW5jeVxuICAgICAgICBjb25zdCB2ZXIgPSBtaW5WZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICBpZiAoIXZlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGB1bmFibGUgdG8gZGV0ZXJtaW5lIG1pbmltdW0gc2VtdmVyIGZvciBwZWVyIGRlcGVuZGVuY3kgJHtuYW1lfUAke3ZlcnNpb259YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXZEZXBzW25hbWVdID0gdmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBrZy5kZXBlbmRlbmNpZXMgPSBzb3J0ZWQoZGVwcyk7XG4gICAgcGtnLmRldkRlcGVuZGVuY2llcyA9IHNvcnRlZChkZXZEZXBzKTtcbiAgICBwa2cucGVlckRlcGVuZGVuY2llcyA9IHNvcnRlZChwZWVyRGVwcyk7XG5cbiAgICBjb25zdCB1cGRhdGVkID0gSlNPTi5zdHJpbmdpZnkocGtnLCB1bmRlZmluZWQsIDIpICsgXCJcXG5cIjtcblxuICAgIGlmIChvcmlnaW5hbCA9PT0gdXBkYXRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdyaXRlRmlsZShyb290UGFja2FnZUpzb24sIHVwZGF0ZWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJQYWNrYWdlUmVzb2x1dGlvbnMoKSB7XG4gICAgY29uc3QgcmVuZGVyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgb3ZlcnJpZGluZ0RlcGVuZGVuY2llcyA9IHRoaXMucHJvamVjdC5kZXBzLmFsbC5maWx0ZXIoXG4gICAgICAgIChkZXApID0+IGRlcC50eXBlID09PSBEZXBlbmRlbmN5VHlwZS5PVkVSUklERVxuICAgICAgKTtcbiAgICAgIGlmICghb3ZlcnJpZGluZ0RlcGVuZGVuY2llcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgb3ZlcnJpZGluZ0RlcGVuZGVuY2llcy5tYXAoKHsgbmFtZSwgdmVyc2lvbiA9IFwiKlwiIH0pID0+IFtuYW1lLCB2ZXJzaW9uXSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5wYWNrYWdlTWFuYWdlcikge1xuICAgICAgY2FzZSBOb2RlUGFja2FnZU1hbmFnZXIuTlBNOlxuICAgICAgICByZXR1cm4geyBvdmVycmlkZXM6IHJlbmRlciB9O1xuICAgICAgY2FzZSBOb2RlUGFja2FnZU1hbmFnZXIuUE5QTTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdC5wYXJlbnRcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogeyBwbnBtOiB7IG92ZXJyaWRlczogcmVuZGVyIH0gfTtcbiAgICAgIGNhc2UgTm9kZVBhY2thZ2VNYW5hZ2VyLllBUk46XG4gICAgICBjYXNlIE5vZGVQYWNrYWdlTWFuYWdlci5ZQVJOMjpcbiAgICAgIGNhc2UgTm9kZVBhY2thZ2VNYW5hZ2VyLllBUk5fQ0xBU1NJQzpcbiAgICAgIGNhc2UgTm9kZVBhY2thZ2VNYW5hZ2VyLllBUk5fQkVSUlk6XG4gICAgICBjYXNlIE5vZGVQYWNrYWdlTWFuYWdlci5CVU46XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geyByZXNvbHV0aW9uczogcmVuZGVyIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJQdWJsaXNoQ29uZmlnKCkge1xuICAgIC8vIFdoZW4gbnBtIHByb3ZlbmFuY2UgaXMgZW5hYmxlZCwgd2UgbmVlZCB0byBhbHdheXMgcmVuZGVyIHRoZSBwdWJsaWMgYWNjZXNzXG4gICAgLy8gQnV0IHdoZW4gbnBtQWNjZXNzIGlzIHRoZSBzZXQgdG8gdGhlIGRlZmF1bHQsIHdlIHByZWZlciB0byBvbWl0IGl0XG4gICAgY29uc3Qgc2hvdWxkT21pdEFjY2VzcyA9XG4gICAgICAhdGhpcy5ucG1Qcm92ZW5hbmNlICYmXG4gICAgICB0aGlzLm5wbUFjY2VzcyA9PT0gZGVmYXVsdE5wbUFjY2Vzcyh0aGlzLnBhY2thZ2VOYW1lKTtcblxuICAgIC8vIG9taXQgdmFsdWVzIGlmIHRoZXkgYXJlIHRoZSBzYW1lIGFzIHRoZSBucG0gZGVmYXVsdHNcbiAgICByZXR1cm4gcmVzb2x2ZUpzb24oXG4gICAgICB7XG4gICAgICAgIHJlZ2lzdHJ5OlxuICAgICAgICAgIHRoaXMubnBtUmVnaXN0cnlVcmwgIT09IERFRkFVTFRfTlBNX1JFR0lTVFJZX1VSTFxuICAgICAgICAgICAgPyB0aGlzLm5wbVJlZ2lzdHJ5VXJsXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgYWNjZXNzOiBzaG91bGRPbWl0QWNjZXNzID8gdW5kZWZpbmVkIDogdGhpcy5ucG1BY2Nlc3MsXG4gICAgICB9LFxuICAgICAgeyBvbWl0RW1wdHk6IHRydWUgfVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlcktleXdvcmRzKCkge1xuICAgIGNvbnN0IGt3ZHMgPSBBcnJheS5mcm9tKHRoaXMua2V5d29yZHMpO1xuICAgIHJldHVybiBzb3J0ZWQoa3dkcy5zb3J0KCkpO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJFbmdpbmVzKCkge1xuICAgIHJldHVybiBzb3J0ZWQodGhpcy5lbmdpbmVzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXV0b0Rpc2NvdmVyQmluYXJpZXMoKSB7XG4gICAgY29uc3QgYmlucmVsID0gXCJiaW5cIjtcbiAgICBjb25zdCBiaW5kaXIgPSBqb2luKHRoaXMucHJvamVjdC5vdXRkaXIsIGJpbnJlbCk7XG4gICAgaWYgKGV4aXN0c1N5bmMoYmluZGlyKSkge1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIHJlYWRkaXJTeW5jKGJpbmRpcikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY2Nlc3NTeW5jKGpvaW4oYmluZGlyLCBmaWxlKSwgY29uc3RhbnRzLlhfT0spO1xuXG4gICAgICAgICAgY29uc3QgYmluUGF0aCA9IGpvaW4oYmlucmVsLCBmaWxlKTtcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBlcnNpc3RlZFBhdGgoYmluUGF0aCk7XG5cbiAgICAgICAgICB0aGlzLmJpbltmaWxlXSA9IG5vcm1hbGl6ZWRQYXRoO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm90IGV4ZWN1dGFibGUsIHNraXBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyQXV0aG9yKG9wdGlvbnM6IE5vZGVQYWNrYWdlT3B0aW9ucykge1xuICAgIGxldCBhdXRob3I7XG4gICAgaWYgKG9wdGlvbnMuYXV0aG9yTmFtZSkge1xuICAgICAgYXV0aG9yID0ge1xuICAgICAgICBuYW1lOiBvcHRpb25zLmF1dGhvck5hbWUsXG4gICAgICAgIGVtYWlsOiBvcHRpb25zLmF1dGhvckVtYWlsLFxuICAgICAgICB1cmw6IG9wdGlvbnMuYXV0aG9yVXJsLFxuICAgICAgICBvcmdhbml6YXRpb246IG9wdGlvbnMuYXV0aG9yT3JnYW5pemF0aW9uID8/IGZhbHNlLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zLmF1dGhvckVtYWlsIHx8XG4gICAgICAgIG9wdGlvbnMuYXV0aG9yVXJsIHx8XG4gICAgICAgIG9wdGlvbnMuYXV0aG9yT3JnYW5pemF0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1wiYXV0aG9yTmFtZVwiIGlzIHJlcXVpcmVkIGlmIHNwZWNpZnlpbmcgXCJhdXRob3JFbWFpbFwiIG9yIFwiYXV0aG9yVXJsXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdXRob3I7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckJpbigpIHtcbiAgICByZXR1cm4gc29ydGVkKHRoaXMuYmluKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyU2NyaXB0cygpIHtcbiAgICBjb25zdCByZXN1bHQ6IGFueSA9IHt9O1xuICAgIGNvbnN0IHRhc2tzID0gdGhpcy5wcm9qZWN0LnRhc2tzLmFsbFxuICAgICAgLmZpbHRlcihcbiAgICAgICAgKHQpID0+XG4gICAgICAgICAgLy8gTXVzdCByZW1vdmUgdG8gcHJldmVudCBvdmVycmlkaW5nIGJ1aWx0LWluIG5wbSBjb21tYW5kICh3aGljaCB3b3VsZCBsb29wKVxuICAgICAgICAgIHQubmFtZSAhPT0gdGhpcy5pbnN0YWxsVGFzay5uYW1lICYmIHQubmFtZSAhPT0gdGhpcy5pbnN0YWxsQ2lUYXNrLm5hbWVcbiAgICAgIClcbiAgICAgIC5zb3J0KCh4LCB5KSA9PiB4Lm5hbWUubG9jYWxlQ29tcGFyZSh5Lm5hbWUpKTtcblxuICAgIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgICAgaWYgKHRoaXMuc2NyaXB0c1RvQmVSZW1vdmVkLmhhcyh0YXNrLm5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0W3Rhc2submFtZV0gPSB0aGlzLm5wbVNjcmlwdEZvclRhc2sodGFzayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIC4uLnRoaXMuc2NyaXB0cyxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBucG1TY3JpcHRGb3JUYXNrKHRhc2s6IFRhc2spIHtcbiAgICByZXR1cm4gYCR7dGhpcy5wcm9qZW5Db21tYW5kfSAke3Rhc2submFtZX1gO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkUGFja2FnZUpzb24oKSB7XG4gICAgY29uc3QgZmlsZSA9IGpvaW4odGhpcy5wcm9qZWN0Lm91dGRpciwgXCJwYWNrYWdlLmpzb25cIik7XG4gICAgaWYgKCFleGlzdHNTeW5jKGZpbGUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlYWRGaWxlU3luYyhmaWxlLCBcInV0Zi04XCIpKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5zdGFsbERlcGVuZGVuY2llcygpIHtcbiAgICB0aGlzLnByb2plY3QubG9nZ2VyLmluZm8oXCJJbnN0YWxsaW5nIGRlcGVuZGVuY2llcy4uLlwiKTtcbiAgICBjb25zdCBydW50aW1lID0gbmV3IFRhc2tSdW50aW1lKHRoaXMucHJvamVjdC5vdXRkaXIpO1xuICAgIGNvbnN0IHRhc2tUb1J1biA9IHRoaXMuaXNBdXRvbWF0ZWRCdWlsZFxuICAgICAgPyB0aGlzLmluc3RhbGxDaVRhc2tcbiAgICAgIDogdGhpcy5pbnN0YWxsVGFzaztcbiAgICBydW50aW1lLnJ1blRhc2sodGFza1RvUnVuLm5hbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25maWd1cmVZYXJuQmVycnkocHJvamVjdDogUHJvamVjdCwgb3B0aW9uczogTm9kZVBhY2thZ2VPcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmVyc2lvbiA9IFwiNC4wLjFcIixcbiAgICAgIHlhcm5SY09wdGlvbnMgPSB7fSxcbiAgICAgIHplcm9JbnN0YWxscyA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zLnlhcm5CZXJyeU9wdGlvbnMgfHwge307XG4gICAgdGhpcy5jaGVja0ZvckNvbmZsaWN0aW5nWWFybk9wdGlvbnMoeWFyblJjT3B0aW9ucyk7XG5cbiAgICAvLyBTZXQgdGhlIGBwYWNrYWdlTWFuYWdlcmAgZmllbGQgaW4gYHBhY2thZ2UuanNvbmAgdG8gdGhlIHZlcnNpb24gc3BlY2lmaWVkLiBUaGlzIHRlbGxzIGBjb3JlcGFja2Agd2hpY2ggdmVyc2lvblxuICAgIC8vIG9mIGB5YXJuYCB0byB1c2UuXG4gICAgdGhpcy5hZGRGaWVsZChcInBhY2thZ2VNYW5hZ2VyXCIsIGB5YXJuQCR7dmVyc2lvbn1gKTtcbiAgICB0aGlzLmNvbmZpZ3VyZVlhcm5CZXJyeUdpdGlnbm9yZSh6ZXJvSW5zdGFsbHMpO1xuXG4gICAgbmV3IFlhcm5yYyhwcm9qZWN0LCB2ZXJzaW9uLCB5YXJuUmNPcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGb3JDb25mbGljdGluZ1lhcm5PcHRpb25zKHlhcm5SY09wdGlvbnM6IFlhcm5yY09wdGlvbnMpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLm5wbUFjY2VzcyAmJlxuICAgICAgeWFyblJjT3B0aW9ucy5ucG1QdWJsaXNoQWNjZXNzICYmXG4gICAgICB0aGlzLm5wbUFjY2Vzcy50b1N0cmluZygpICE9PSB5YXJuUmNPcHRpb25zLm5wbVB1Ymxpc2hBY2Nlc3MudG9TdHJpbmcoKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBucG1BY2Nlc3MgKCR7dGhpcy5ucG1BY2Nlc3N9KSBhbmQgeWFyblJjT3B0aW9ucy5ucG1QdWJsaXNoQWNjZXNzICgke3lhcm5SY09wdGlvbnMubnBtUHVibGlzaEFjY2Vzc30pIHRvIGRpZmZlcmVudCB2YWx1ZXMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm5wbVJlZ2lzdHJ5VXJsICYmXG4gICAgICB5YXJuUmNPcHRpb25zLm5wbVJlZ2lzdHJ5U2VydmVyICYmXG4gICAgICB0aGlzLm5wbVJlZ2lzdHJ5VXJsICE9PSB5YXJuUmNPcHRpb25zLm5wbVJlZ2lzdHJ5U2VydmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IG5wbVJlZ2lzdHJ5VXJsICgke3RoaXMubnBtUmVnaXN0cnlVcmx9KSBhbmQgeWFyblJjT3B0aW9ucy5ucG1SZWdpc3RyeVNlcnZlciAoJHt5YXJuUmNPcHRpb25zLm5wbVJlZ2lzdHJ5U2VydmVyfSkgdG8gZGlmZmVyZW50IHZhbHVlcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTZWUgaHR0cHM6Ly95YXJucGtnLmNvbS9nZXR0aW5nLXN0YXJ0ZWQvcWEjd2hpY2gtZmlsZXMtc2hvdWxkLWJlLWdpdGlnbm9yZWQgKi9cbiAgcHJpdmF0ZSBjb25maWd1cmVZYXJuQmVycnlHaXRpZ25vcmUoemVyb0luc3RhbGxzOiBib29sZWFuKSB7XG4gICAgY29uc3QgeyBnaXRpZ25vcmUgfSA9IHRoaXMucHJvamVjdDtcblxuICAgIC8vIFRoZXNlIHBhdHRlcm5zIGFyZSB0aGUgc2FtZSB3aGV0aGVyIG9yIG5vdCB5b3UncmUgdXNpbmcgemVyby1pbnN0YWxsc1xuICAgIGdpdGlnbm9yZS5leGNsdWRlKFwiLnlhcm4vKlwiKTtcbiAgICBnaXRpZ25vcmUuaW5jbHVkZShcbiAgICAgIFwiLnlhcm4vcGF0Y2hlc1wiLFxuICAgICAgXCIueWFybi9wbHVnaW5zXCIsXG4gICAgICBcIi55YXJuL3JlbGVhc2VzXCIsXG4gICAgICBcIi55YXJuL3Nka3NcIixcbiAgICAgIFwiLnlhcm4vdmVyc2lvbnNcIlxuICAgICk7XG5cbiAgICBpZiAoemVyb0luc3RhbGxzKSB7XG4gICAgICBnaXRpZ25vcmUuaW5jbHVkZShcIiEueWFybi9jYWNoZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2l0aWdub3JlLmV4Y2x1ZGUoXCIucG5wLipcIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVlckRlcGVuZGVuY3lPcHRpb25zIHtcbiAgLyoqXG4gICAqIEF1dG9tYXRpY2FsbHkgYWRkIGEgcGlubmVkIGRldiBkZXBlbmRlbmN5LlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBwaW5uZWREZXZEZXBlbmRlbmN5PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUaGUgbm9kZSBwYWNrYWdlIG1hbmFnZXIgdG8gdXNlLlxuICovXG5leHBvcnQgZW51bSBOb2RlUGFja2FnZU1hbmFnZXIge1xuICAvKipcbiAgICogVXNlIGB5YXJuYCBhcyB0aGUgcGFja2FnZSBtYW5hZ2VyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBGb3IgYHlhcm5gIDEueCB1c2UgYFlBUk5fQ0xBU1NJQ2AgZm9yIGB5YXJuYCA+PSAyIHVzZSBgWUFSTl9CRVJSWWAuIEN1cnJlbnRseSwgYE5vZGVQYWNrYWdlTWFuYWdlci5ZQVJOYCBtZWFucyBgWUFSTl9DTEFTU0lDYC4gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgcmVwdXJwb3NlIGl0IHRvIG1lYW4gYFlBUk5fQkVSUllgLlxuICAgKi9cbiAgWUFSTiA9IFwieWFyblwiLFxuXG4gIC8qKlxuICAgKiBVc2UgYHlhcm5gIHZlcnNpb25zID49IDIgYXMgdGhlIHBhY2thZ2UgbWFuYWdlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIFlBUk5fQkVSUlkgaW5zdGVhZFxuICAgKi9cbiAgWUFSTjIgPSBcInlhcm4yXCIsXG5cbiAgLyoqXG4gICAqIFVzZSBgeWFybmAgMS54IGFzIHRoZSBwYWNrYWdlIG1hbmFnZXIuXG4gICAqL1xuICBZQVJOX0NMQVNTSUMgPSBcInlhcm5fY2xhc3NpY1wiLFxuXG4gIC8qKlxuICAgKiBVc2UgYHlhcm5gIHZlcnNpb25zID49IDIgYXMgdGhlIHBhY2thZ2UgbWFuYWdlci5cbiAgICovXG4gIFlBUk5fQkVSUlkgPSBcInlhcm5fYmVycnlcIixcblxuICAvKipcbiAgICogVXNlIGBucG1gIGFzIHRoZSBwYWNrYWdlIG1hbmFnZXIuXG4gICAqL1xuICBOUE0gPSBcIm5wbVwiLFxuXG4gIC8qKlxuICAgKiBVc2UgYHBucG1gIGFzIHRoZSBwYWNrYWdlIG1hbmFnZXIuXG4gICAqL1xuICBQTlBNID0gXCJwbnBtXCIsXG5cbiAgLyoqXG4gICAqIFVzZSBgYnVuYCBhcyB0aGUgcGFja2FnZSBtYW5hZ2VyXG4gICAqL1xuICBCVU4gPSBcImJ1blwiLFxufVxuXG4vKipcbiAqIE5wbSBwYWNrYWdlIGFjY2VzcyBsZXZlbFxuICovXG5leHBvcnQgZW51bSBOcG1BY2Nlc3Mge1xuICAvKipcbiAgICogUGFja2FnZSBpcyBwdWJsaWMuXG4gICAqL1xuICBQVUJMSUMgPSBcInB1YmxpY1wiLFxuXG4gIC8qKlxuICAgKiBQYWNrYWdlIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIHdpdGggY3JlZGVudGlhbHMuXG4gICAqL1xuICBSRVNUUklDVEVEID0gXCJyZXN0cmljdGVkXCIsXG59XG5cbi8qKlxuICogQ29uZmlndXJlIFlhcm4gQmVycnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBZYXJuQmVycnlPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgZnVsbHkgc3BlY2lmaWVkIHZlcnNpb24gdG8gdXNlIGZvciB5YXJuIChlLmcuLCB4LngueClcbiAgICpcbiAgICogQGRlZmF1bHQgLSA0LjAuMVxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHlhcm5yYyBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGEgYmxhbmsgWWFybiBSQyBmaWxlXG4gICAqL1xuICByZWFkb25seSB5YXJuUmNPcHRpb25zPzogWWFybnJjT3B0aW9ucztcblxuICAvKipcbiAgICogU2hvdWxkIHplcm8taW5zdGFsbHMgYmUgZW5hYmxlZD9cbiAgICogTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly95YXJucGtnLmNvbS9mZWF0dXJlcy9jYWNoaW5nI3plcm8taW5zdGFsbHNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHplcm9JbnN0YWxscz86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBOcG1EZXBlbmRlbmNpZXMge1xuICByZWFkb25seSBkZXBlbmRlbmNpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHJlYWRvbmx5IGRldkRlcGVuZGVuY2llczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgcmVhZG9ubHkgcGVlckRlcGVuZGVuY2llczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG5wbSBwYWNrYWdlIGlzIFwic2NvcGVkXCIgKGkuZS4gaXQgc3RhcnRzIHdpdGggXCJ4eHhAXCIpLlxuICovXG5mdW5jdGlvbiBpc1Njb3BlZChwYWNrYWdlTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBwYWNrYWdlTmFtZS5pbmNsdWRlcyhcIkBcIik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHROcG1BY2Nlc3MocGFja2FnZU5hbWU6IHN0cmluZykge1xuICByZXR1cm4gaXNTY29wZWQocGFja2FnZU5hbWUpID8gTnBtQWNjZXNzLlJFU1RSSUNURUQgOiBOcG1BY2Nlc3MuUFVCTElDO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE5wbVRva2VuKFxuICBucG1Ub2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICByZWdpc3RyeTogc3RyaW5nIHwgdW5kZWZpbmVkXG4pIHtcbiAgLy8gaWYgd2UgYXJlIHB1Ymxpc2hpbmcgdG8gQVdTIENkb2RlQXJ0aWZhY3QsIG5vIE5QTV9UT0tFTiB1c2VkICh3aWxsIGJlIHJlcXVlc3RlZCB1c2luZyBBV1MgQ0xJIGxhdGVyKS5cbiAgaWYgKGlzQXdzQ29kZUFydGlmYWN0UmVnaXN0cnkocmVnaXN0cnkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGlmIHdlIGFyZSBwdWJsaXNoaW5nIHRvIEdpdEh1YiBQYWNrYWdlcywgZGVmYXVsdCB0byBHSVRIVUJfVE9LRU4uXG4gIGNvbnN0IGlzR2l0SHViUGFja2FnZXMgPSByZWdpc3RyeSA9PT0gR0lUSFVCX1BBQ0tBR0VTX1JFR0lTVFJZO1xuICByZXR1cm4gKFxuICAgIG5wbVRva2VuID8/XG4gICAgKGlzR2l0SHViUGFja2FnZXMgPyBERUZBVUxUX0dJVEhVQl9UT0tFTl9TRUNSRVQgOiBERUZBVUxUX05QTV9UT0tFTl9TRUNSRVQpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxvY2tmaWxlKHBhY2thZ2VNYW5hZ2VyOiBOb2RlUGFja2FnZU1hbmFnZXIpIHtcbiAgaWYgKFxuICAgIHBhY2thZ2VNYW5hZ2VyID09PSBOb2RlUGFja2FnZU1hbmFnZXIuWUFSTiB8fFxuICAgIHBhY2thZ2VNYW5hZ2VyID09PSBOb2RlUGFja2FnZU1hbmFnZXIuWUFSTjIgfHxcbiAgICBwYWNrYWdlTWFuYWdlciA9PT0gTm9kZVBhY2thZ2VNYW5hZ2VyLllBUk5fQ0xBU1NJQyB8fFxuICAgIHBhY2thZ2VNYW5hZ2VyID09PSBOb2RlUGFja2FnZU1hbmFnZXIuWUFSTl9CRVJSWVxuICApIHtcbiAgICByZXR1cm4gXCJ5YXJuLmxvY2tcIjtcbiAgfSBlbHNlIGlmIChwYWNrYWdlTWFuYWdlciA9PT0gTm9kZVBhY2thZ2VNYW5hZ2VyLk5QTSkge1xuICAgIHJldHVybiBcInBhY2thZ2UtbG9jay5qc29uXCI7XG4gIH0gZWxzZSBpZiAocGFja2FnZU1hbmFnZXIgPT09IE5vZGVQYWNrYWdlTWFuYWdlci5QTlBNKSB7XG4gICAgcmV0dXJuIFwicG5wbS1sb2NrLnlhbWxcIjtcbiAgfSBlbHNlIGlmIChwYWNrYWdlTWFuYWdlciA9PT0gTm9kZVBhY2thZ2VNYW5hZ2VyLkJVTikge1xuICAgIHJldHVybiBcImJ1bi5sb2NrYlwiO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBwYWNrYWdlIG1hbmFnZXIgJHtwYWNrYWdlTWFuYWdlcn1gKTtcbn1cbiJdfQ==