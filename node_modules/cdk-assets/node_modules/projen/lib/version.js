"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReleasableCommits = exports.Version = exports.CHANGES_SINCE_LAST_RELEASE = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const path_1 = require("path");
const component_1 = require("./component");
const dependencies_1 = require("./dependencies");
const node_package_1 = require("./javascript/node-package");
/**
 * This command determines if there were any changes since the last release in a cross-platform compatible way.
 * It is used as a condition for both the `bump` and the `release` tasks.
 *
 * Explanation:
 *  - log commits                                               | git log
 *  - limit log output to a single line per commit              | --oneline
 *  - looks only at the most recent commit                      | -1
 *  - silent grep output                                        | grep -q
 *  - exits with code 0 if a match is found                     | grep -q "chore(release):"
 *  - exits with code 1 if a match is found (reverse-match)     | grep -qv "chore(release):"
 */
exports.CHANGES_SINCE_LAST_RELEASE = 'git log --oneline -1 | grep -qv "chore(release):"';
/**
 * The default package to be used for commit-and-tag-version
 */
const COMMIT_AND_TAG_VERSION_DEFAULT = "commit-and-tag-version@^12";
class Version extends component_1.Component {
    constructor(scope, options) {
        super(scope);
        this.changelogFileName = "changelog.md";
        this.versionFileName = "version.txt";
        this.releaseTagFileName = "releasetag.txt";
        this.bumpPackage = options.bumpPackage ?? COMMIT_AND_TAG_VERSION_DEFAULT;
        // This component is language independent.
        // However, when in the Node.js ecosystem, we can improve the experience by adding a dev dependency on the bump package.
        const node = node_package_1.NodePackage.of(this.project);
        if (node) {
            const { name: bumpName, version: bumpVersion } = dependencies_1.Dependencies.parseDependency(this.bumpPackage);
            if (!node.project.deps.isDependencySatisfied(bumpName, dependencies_1.DependencyType.BUILD, bumpVersion ?? "*")) {
                node.project.deps.addDependency(this.bumpPackage, dependencies_1.DependencyType.BUILD);
            }
        }
        const versionInputFile = options.versionInputFile;
        const changelogFile = path_1.posix.join(options.artifactsDirectory, this.changelogFileName);
        const bumpFile = path_1.posix.join(options.artifactsDirectory, this.versionFileName);
        const releaseTagFile = path_1.posix.join(options.artifactsDirectory, this.releaseTagFileName);
        const commonEnv = {
            OUTFILE: versionInputFile,
            CHANGELOG: changelogFile,
            BUMPFILE: bumpFile,
            RELEASETAG: releaseTagFile,
            RELEASE_TAG_PREFIX: options.tagPrefix ?? "",
            // doesn't work if custom configuration is long
            VERSIONRCOPTIONS: JSON.stringify(options.versionrcOptions),
            BUMP_PACKAGE: this.bumpPackage,
        };
        if (options.releasableCommits) {
            commonEnv.RELEASABLE_COMMITS = options.releasableCommits.cmd;
        }
        this.bumpTask = this.project.addTask("bump", {
            description: "Bumps version based on latest git tag and generates a changelog entry",
            condition: exports.CHANGES_SINCE_LAST_RELEASE,
            env: { ...commonEnv },
        });
        this.bumpTask.builtin("release/bump-version");
        this.unbumpTask = this.project.addTask("unbump", {
            description: "Restores version to 0.0.0",
            env: { ...commonEnv },
        });
        this.unbumpTask.builtin("release/reset-version");
        this.project.addGitIgnore(`/${changelogFile}`);
        this.project.addGitIgnore(`/${bumpFile}`);
        this.project.addPackageIgnore(`/${changelogFile}`);
        this.project.addPackageIgnore(`/${bumpFile}`);
    }
}
exports.Version = Version;
_a = JSII_RTTI_SYMBOL_1;
Version[_a] = { fqn: "projen.Version", version: "0.88.0" };
/**
 * @deprecated use `version.bumpPackage` on the component instance instead
 */
Version.STANDARD_VERSION = COMMIT_AND_TAG_VERSION_DEFAULT;
/**
 * Find commits that should be considered releasable to decide if a release is required.
 */
class ReleasableCommits {
    /**
     * Release every commit
     *
     * This will only not release if the most recent commit is tagged with the latest matching tag.
     *
     * @param path Consider only commits that are enough to explain how the files that match the specified paths came to be.
     * This path is relative to the current working dir of the `bump` task, i.e. to only consider commits of a subproject use `"."`.
     */
    static everyCommit(path) {
        const cmd = `git log --oneline $LATEST_TAG..HEAD`;
        return new ReleasableCommits(withPath(cmd, path));
    }
    /**
     * Limit commits by their conventional commit type
     *
     * This will only release commit that match one of the provided types.
     * Commits are required to follow the conventional commit spec and will be ignored otherwise.
     *
     * @param types List of conventional commit types that should be released
     * @param path Consider only commits that are enough to explain how the files that match the specified paths came to be.
     * This path is relative to the current working dir of the `bump` task, i.e. to only consider commits of a subproject use `"."`.
     */
    static ofType(types, path) {
        const allowedTypes = types.join("|");
        // @see: https://github.com/conventional-commits/parser/blob/eeefb961ebf5b9dfea0fea8b06f8ad34a1e439b9/lib/parser.js
        // -E requires this to be POSIX Extended Regular Expression, which comes with certain limitations
        // see https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions for details
        const cmd = `git log --no-merges --oneline $LATEST_TAG..HEAD -E --grep "^(${allowedTypes}){1}(\\([^()[:space:]]+\\))?(!)?:[[:blank:]]+.+"`;
        return new ReleasableCommits(withPath(cmd, path));
    }
    /**
     * Release only features and fixes
     *
     * Shorthand for `ReleasableCommits.onlyOfType(['feat', 'fix'])`.
     *
     * @param path Consider only commits that are enough to explain how the files that match the specified paths came to be.
     * This path is relative to the current working dir of the `bump` task, i.e. to only consider commits of a subproject use `"."`.
     */
    static featuresAndFixes(path) {
        return ReleasableCommits.ofType(["feat", "fix"], path);
    }
    /**
     * Use an arbitrary shell command to find releasable commits since the latest tag.
     *
     * A new release will be initiated, if the number of returned commits is greater than zero.
     * Must return a newline separate list of commits that should considered releasable.
     * `$LATEST_TAG` will be replaced with the actual latest tag for the given prefix.*
     *
     * @example "git log --oneline $LATEST_TAG..HEAD -- ."
     */
    static exec(cmd) {
        return new ReleasableCommits(cmd);
    }
    constructor(cmd) {
        this.cmd = cmd;
    }
}
exports.ReleasableCommits = ReleasableCommits;
_b = JSII_RTTI_SYMBOL_1;
ReleasableCommits[_b] = { fqn: "projen.ReleasableCommits", version: "0.88.0" };
/**
 * Append a path argument to a git command if one is provided
 */
function withPath(cmd, path) {
    if (path !== undefined) {
        return `${cmd} -- ${path}`;
    }
    return cmd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy92ZXJzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsK0JBQTZCO0FBRTdCLDJDQUF3QztBQUN4QyxpREFBOEQ7QUFDOUQsNERBQXdEO0FBR3hEOzs7Ozs7Ozs7OztHQVdHO0FBQ1UsUUFBQSwwQkFBMEIsR0FDckMsbURBQW1ELENBQUM7QUFFdEQ7O0dBRUc7QUFDSCxNQUFNLDhCQUE4QixHQUFHLDRCQUE0QixDQUFDO0FBK0NwRSxNQUFhLE9BQVEsU0FBUSxxQkFBUztJQThCcEMsWUFBWSxLQUFpQixFQUFFLE9BQXVCO1FBQ3BELEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUViLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxjQUFjLENBQUM7UUFDeEMsSUFBSSxDQUFDLGVBQWUsR0FBRyxhQUFhLENBQUM7UUFDckMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLGdCQUFnQixDQUFDO1FBQzNDLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsSUFBSSw4QkFBOEIsQ0FBQztRQUV6RSwwQ0FBMEM7UUFDMUMsd0hBQXdIO1FBQ3hILE1BQU0sSUFBSSxHQUFHLDBCQUFXLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMxQyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ1QsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUM1QywyQkFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDakQsSUFDRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUN0QyxRQUFRLEVBQ1IsNkJBQWMsQ0FBQyxLQUFLLEVBQ3BCLFdBQVcsSUFBSSxHQUFHLENBQ25CLEVBQ0QsQ0FBQztnQkFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUks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QztRQUVyQyxtSEFBbUg7UUFDbkgsaUdBQWlHO1FBQ2pHLHVHQUF1RztRQUN2RyxNQUFNLEdBQUcsR0FBRyxnRUFBZ0UsWUFBWSxrREFBa0QsQ0FBQztRQUUzSSxPQUFPLElBQUksaUJBQWlCLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQWE7UUFDbkMsT0FBTyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFXO1FBQ3JCLE9BQU8sSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsWUFBMkIsR0FBVztRQUFYLFFBQUcsR0FBSCxHQUFHLENBQVE7SUFBRyxDQUFDOztBQTVENUMsOENBNkRDOzs7QUFFRDs7R0FFRztBQUNILFNBQVMsUUFBUSxDQUFDLEdBQVcsRUFBRSxJQUFhO0lBQzFDLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQ3ZCLE9BQU8sR0FBRyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvc2l4IH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IElDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBEZXBlbmRlbmNpZXMsIERlcGVuZGVuY3lUeXBlIH0gZnJvbSBcIi4vZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgeyBOb2RlUGFja2FnZSB9IGZyb20gXCIuL2phdmFzY3JpcHQvbm9kZS1wYWNrYWdlXCI7XG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIi4vdGFza1wiO1xuXG4vKipcbiAqIFRoaXMgY29tbWFuZCBkZXRlcm1pbmVzIGlmIHRoZXJlIHdlcmUgYW55IGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgcmVsZWFzZSBpbiBhIGNyb3NzLXBsYXRmb3JtIGNvbXBhdGlibGUgd2F5LlxuICogSXQgaXMgdXNlZCBhcyBhIGNvbmRpdGlvbiBmb3IgYm90aCB0aGUgYGJ1bXBgIGFuZCB0aGUgYHJlbGVhc2VgIHRhc2tzLlxuICpcbiAqIEV4cGxhbmF0aW9uOlxuICogIC0gbG9nIGNvbW1pdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZ2l0IGxvZ1xuICogIC0gbGltaXQgbG9nIG91dHB1dCB0byBhIHNpbmdsZSBsaW5lIHBlciBjb21taXQgICAgICAgICAgICAgIHwgLS1vbmVsaW5lXG4gKiAgLSBsb29rcyBvbmx5IGF0IHRoZSBtb3N0IHJlY2VudCBjb21taXQgICAgICAgICAgICAgICAgICAgICAgfCAtMVxuICogIC0gc2lsZW50IGdyZXAgb3V0cHV0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZ3JlcCAtcVxuICogIC0gZXhpdHMgd2l0aCBjb2RlIDAgaWYgYSBtYXRjaCBpcyBmb3VuZCAgICAgICAgICAgICAgICAgICAgIHwgZ3JlcCAtcSBcImNob3JlKHJlbGVhc2UpOlwiXG4gKiAgLSBleGl0cyB3aXRoIGNvZGUgMSBpZiBhIG1hdGNoIGlzIGZvdW5kIChyZXZlcnNlLW1hdGNoKSAgICAgfCBncmVwIC1xdiBcImNob3JlKHJlbGVhc2UpOlwiXG4gKi9cbmV4cG9ydCBjb25zdCBDSEFOR0VTX1NJTkNFX0xBU1RfUkVMRUFTRSA9XG4gICdnaXQgbG9nIC0tb25lbGluZSAtMSB8IGdyZXAgLXF2IFwiY2hvcmUocmVsZWFzZSk6XCInO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHBhY2thZ2UgdG8gYmUgdXNlZCBmb3IgY29tbWl0LWFuZC10YWctdmVyc2lvblxuICovXG5jb25zdCBDT01NSVRfQU5EX1RBR19WRVJTSU9OX0RFRkFVTFQgPSBcImNvbW1pdC1hbmQtdGFnLXZlcnNpb25AXjEyXCI7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYFZlcnNpb25gLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgbmFtZSBvZiBhIC5qc29uIGZpbGUgdG8gc2V0IHRoZSBgdmVyc2lvbmAgZmllbGQgaW4gYWZ0ZXIgYSBidW1wLlxuICAgKlxuICAgKiBAZXhhbXBsZSBcInBhY2thZ2UuanNvblwiXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uSW5wdXRGaWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaW50byB3aGljaCBgY2hhbmdlbG9nLm1kYCBhbmQgYHZlcnNpb24udHh0YCBmaWxlc1xuICAgKiBhcmUgZW1pdHRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGFydGlmYWN0c0RpcmVjdG9yeTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDdXN0b20gY29uZmlndXJhdGlvbiBmb3IgdmVyc2lvbnJjIGZpbGUgdXNlZCBieSBzdGFuZGFyZC1yZWxlYXNlXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9ucmNPcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55PjtcblxuICAvKipcbiAgICogVGhlIHRhZyBwcmVmaXggY29ycmVzcG9uZGluZyB0byB0aGlzIHZlcnNpb24uXG4gICAqL1xuICByZWFkb25seSB0YWdQcmVmaXg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbmQgY29tbWl0cyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHJlbGVhc2FibGVcbiAgICogVXNlZCB0byBkZWNpZGUgaWYgYSByZWxlYXNlIGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBSZWxlYXNhYmxlQ29tbWl0cy5ldmVyeUNvbW1pdCgpXG4gICAqL1xuICByZWFkb25seSByZWxlYXNhYmxlQ29tbWl0cz86IFJlbGVhc2FibGVDb21taXRzO1xuXG4gIC8qKlxuICAgKiBUaGUgYGNvbW1pdC1hbmQtdGFnLXZlcnNpb25gIGNvbXBhdGlibGUgcGFja2FnZSB1c2VkIHRvIGJ1bXAgdGhlIHBhY2thZ2UgdmVyc2lvbiwgYXMgYSBkZXBlbmRlbmN5IHN0cmluZy5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgYW55IGNvbXBhdGlibGUgcGFja2FnZSB2ZXJzaW9uLCBpbmNsdWRpbmcgdGhlIGRlcHJlY2F0ZWQgYHN0YW5kYXJkLXZlcnNpb25AOWAuXG4gICAqXG4gICAqIEBkZWZhdWx0IFwiY29tbWl0LWFuZC10YWctdmVyc2lvbkAxMlwiXG4gICAqL1xuICByZWFkb25seSBidW1wUGFja2FnZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFZlcnNpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGB2ZXJzaW9uLmJ1bXBQYWNrYWdlYCBvbiB0aGUgY29tcG9uZW50IGluc3RhbmNlIGluc3RlYWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU1RBTkRBUkRfVkVSU0lPTiA9IENPTU1JVF9BTkRfVEFHX1ZFUlNJT05fREVGQVVMVDtcblxuICBwdWJsaWMgcmVhZG9ubHkgYnVtcFRhc2s6IFRhc2s7XG4gIHB1YmxpYyByZWFkb25seSB1bmJ1bXBUYXNrOiBUYXNrO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgY2hhbmdlbG9nIGZpbGUgKHVuZGVyIGBhcnRpZmFjdHNEaXJlY3RvcnlgKS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjaGFuZ2Vsb2dGaWxlTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSB2ZXJzaW9uICh1bmRlciBgYXJ0aWZhY3RzRGlyZWN0b3J5YCkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdmVyc2lvbkZpbGVOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgY29udGFpbnMgdGhlIHJlbGVhc2UgdGFnICh1bmRlciBgYXJ0aWZhY3RzRGlyZWN0b3J5YCkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcmVsZWFzZVRhZ0ZpbGVOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYWNrYWdlIHVzZWQgdG8gYnVtcCBwYWNrYWdlIHZlcnNpb25zLCBhcyBhIGRlcGVuZGVuY3kgc3RyaW5nLlxuICAgKiBUaGlzIGlzIGEgYGNvbW1pdC1hbmQtdGFnLXZlcnNpb25gIGNvbXBhdGlibGUgcGFja2FnZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBidW1wUGFja2FnZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBJQ29uc3RydWN0LCBvcHRpb25zOiBWZXJzaW9uT3B0aW9ucykge1xuICAgIHN1cGVyKHNjb3BlKTtcblxuICAgIHRoaXMuY2hhbmdlbG9nRmlsZU5hbWUgPSBcImNoYW5nZWxvZy5tZFwiO1xuICAgIHRoaXMudmVyc2lvbkZpbGVOYW1lID0gXCJ2ZXJzaW9uLnR4dFwiO1xuICAgIHRoaXMucmVsZWFzZVRhZ0ZpbGVOYW1lID0gXCJyZWxlYXNldGFnLnR4dFwiO1xuICAgIHRoaXMuYnVtcFBhY2thZ2UgPSBvcHRpb25zLmJ1bXBQYWNrYWdlID8/IENPTU1JVF9BTkRfVEFHX1ZFUlNJT05fREVGQVVMVDtcblxuICAgIC8vIFRoaXMgY29tcG9uZW50IGlzIGxhbmd1YWdlIGluZGVwZW5kZW50LlxuICAgIC8vIEhvd2V2ZXIsIHdoZW4gaW4gdGhlIE5vZGUuanMgZWNvc3lzdGVtLCB3ZSBjYW4gaW1wcm92ZSB0aGUgZXhwZXJpZW5jZSBieSBhZGRpbmcgYSBkZXYgZGVwZW5kZW5jeSBvbiB0aGUgYnVtcCBwYWNrYWdlLlxuICAgIGNvbnN0IG5vZGUgPSBOb2RlUGFja2FnZS5vZih0aGlzLnByb2plY3QpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBjb25zdCB7IG5hbWU6IGJ1bXBOYW1lLCB2ZXJzaW9uOiBidW1wVmVyc2lvbiB9ID1cbiAgICAgICAgRGVwZW5kZW5jaWVzLnBhcnNlRGVwZW5kZW5jeSh0aGlzLmJ1bXBQYWNrYWdlKTtcbiAgICAgIGlmIChcbiAgICAgICAgIW5vZGUucHJvamVjdC5kZXBzLmlzRGVwZW5kZW5jeVNhdGlzZmllZChcbiAgICAgICAgICBidW1wTmFtZSxcbiAgICAgICAgICBEZXBlbmRlbmN5VHlwZS5CVUlMRCxcbiAgICAgICAgICBidW1wVmVyc2lvbiA/PyBcIipcIlxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgbm9kZS5wcm9qZWN0LmRlcHMuYWRkRGVwZW5kZW5jeSh0aGlzLmJ1bXBQYWNrYWdlLCBEZXBlbmRlbmN5VHlwZS5CVUlMRCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbklucHV0RmlsZSA9IG9wdGlvbnMudmVyc2lvbklucHV0RmlsZTtcblxuICAgIGNvbnN0IGNoYW5nZWxvZ0ZpbGUgPSBwb3NpeC5qb2luKFxuICAgICAgb3B0aW9ucy5hcnRpZmFjdHNEaXJlY3RvcnksXG4gICAgICB0aGlzLmNoYW5nZWxvZ0ZpbGVOYW1lXG4gICAgKTtcbiAgICBjb25zdCBidW1wRmlsZSA9IHBvc2l4LmpvaW4oXG4gICAgICBvcHRpb25zLmFydGlmYWN0c0RpcmVjdG9yeSxcbiAgICAgIHRoaXMudmVyc2lvbkZpbGVOYW1lXG4gICAgKTtcbiAgICBjb25zdCByZWxlYXNlVGFnRmlsZSA9IHBvc2l4LmpvaW4oXG4gICAgICBvcHRpb25zLmFydGlmYWN0c0RpcmVjdG9yeSxcbiAgICAgIHRoaXMucmVsZWFzZVRhZ0ZpbGVOYW1lXG4gICAgKTtcblxuICAgIGNvbnN0IGNvbW1vbkVudjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIE9VVEZJTEU6IHZlcnNpb25JbnB1dEZpbGUsXG4gICAgICBDSEFOR0VMT0c6IGNoYW5nZWxvZ0ZpbGUsXG4gICAgICBCVU1QRklMRTogYnVtcEZpbGUsXG4gICAgICBSRUxFQVNFVEFHOiByZWxlYXNlVGFnRmlsZSxcbiAgICAgIFJFTEVBU0VfVEFHX1BSRUZJWDogb3B0aW9ucy50YWdQcmVmaXggPz8gXCJcIixcbiAgICAgIC8vIGRvZXNuJ3Qgd29yayBpZiBjdXN0b20gY29uZmlndXJhdGlvbiBpcyBsb25nXG4gICAgICBWRVJTSU9OUkNPUFRJT05TOiBKU09OLnN0cmluZ2lmeShvcHRpb25zLnZlcnNpb25yY09wdGlvbnMpLFxuICAgICAgQlVNUF9QQUNLQUdFOiB0aGlzLmJ1bXBQYWNrYWdlLFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5yZWxlYXNhYmxlQ29tbWl0cykge1xuICAgICAgY29tbW9uRW52LlJFTEVBU0FCTEVfQ09NTUlUUyA9IG9wdGlvbnMucmVsZWFzYWJsZUNvbW1pdHMuY21kO1xuICAgIH1cblxuICAgIHRoaXMuYnVtcFRhc2sgPSB0aGlzLnByb2plY3QuYWRkVGFzayhcImJ1bXBcIiwge1xuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgIFwiQnVtcHMgdmVyc2lvbiBiYXNlZCBvbiBsYXRlc3QgZ2l0IHRhZyBhbmQgZ2VuZXJhdGVzIGEgY2hhbmdlbG9nIGVudHJ5XCIsXG4gICAgICBjb25kaXRpb246IENIQU5HRVNfU0lOQ0VfTEFTVF9SRUxFQVNFLFxuICAgICAgZW52OiB7IC4uLmNvbW1vbkVudiB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5idW1wVGFzay5idWlsdGluKFwicmVsZWFzZS9idW1wLXZlcnNpb25cIik7XG5cbiAgICB0aGlzLnVuYnVtcFRhc2sgPSB0aGlzLnByb2plY3QuYWRkVGFzayhcInVuYnVtcFwiLCB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJSZXN0b3JlcyB2ZXJzaW9uIHRvIDAuMC4wXCIsXG4gICAgICBlbnY6IHsgLi4uY29tbW9uRW52IH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLnVuYnVtcFRhc2suYnVpbHRpbihcInJlbGVhc2UvcmVzZXQtdmVyc2lvblwiKTtcblxuICAgIHRoaXMucHJvamVjdC5hZGRHaXRJZ25vcmUoYC8ke2NoYW5nZWxvZ0ZpbGV9YCk7XG4gICAgdGhpcy5wcm9qZWN0LmFkZEdpdElnbm9yZShgLyR7YnVtcEZpbGV9YCk7XG4gICAgdGhpcy5wcm9qZWN0LmFkZFBhY2thZ2VJZ25vcmUoYC8ke2NoYW5nZWxvZ0ZpbGV9YCk7XG4gICAgdGhpcy5wcm9qZWN0LmFkZFBhY2thZ2VJZ25vcmUoYC8ke2J1bXBGaWxlfWApO1xuICB9XG59XG5cbi8qKlxuICogRmluZCBjb21taXRzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcmVsZWFzYWJsZSB0byBkZWNpZGUgaWYgYSByZWxlYXNlIGlzIHJlcXVpcmVkLlxuICovXG5leHBvcnQgY2xhc3MgUmVsZWFzYWJsZUNvbW1pdHMge1xuICAvKipcbiAgICogUmVsZWFzZSBldmVyeSBjb21taXRcbiAgICpcbiAgICogVGhpcyB3aWxsIG9ubHkgbm90IHJlbGVhc2UgaWYgdGhlIG1vc3QgcmVjZW50IGNvbW1pdCBpcyB0YWdnZWQgd2l0aCB0aGUgbGF0ZXN0IG1hdGNoaW5nIHRhZy5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggQ29uc2lkZXIgb25seSBjb21taXRzIHRoYXQgYXJlIGVub3VnaCB0byBleHBsYWluIGhvdyB0aGUgZmlsZXMgdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHBhdGhzIGNhbWUgdG8gYmUuXG4gICAqIFRoaXMgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpciBvZiB0aGUgYGJ1bXBgIHRhc2ssIGkuZS4gdG8gb25seSBjb25zaWRlciBjb21taXRzIG9mIGEgc3VicHJvamVjdCB1c2UgYFwiLlwiYC5cbiAgICovXG4gIHN0YXRpYyBldmVyeUNvbW1pdChwYXRoPzogc3RyaW5nKSB7XG4gICAgY29uc3QgY21kID0gYGdpdCBsb2cgLS1vbmVsaW5lICRMQVRFU1RfVEFHLi5IRUFEYDtcbiAgICByZXR1cm4gbmV3IFJlbGVhc2FibGVDb21taXRzKHdpdGhQYXRoKGNtZCwgcGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbWl0IGNvbW1pdHMgYnkgdGhlaXIgY29udmVudGlvbmFsIGNvbW1pdCB0eXBlXG4gICAqXG4gICAqIFRoaXMgd2lsbCBvbmx5IHJlbGVhc2UgY29tbWl0IHRoYXQgbWF0Y2ggb25lIG9mIHRoZSBwcm92aWRlZCB0eXBlcy5cbiAgICogQ29tbWl0cyBhcmUgcmVxdWlyZWQgdG8gZm9sbG93IHRoZSBjb252ZW50aW9uYWwgY29tbWl0IHNwZWMgYW5kIHdpbGwgYmUgaWdub3JlZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlcyBMaXN0IG9mIGNvbnZlbnRpb25hbCBjb21taXQgdHlwZXMgdGhhdCBzaG91bGQgYmUgcmVsZWFzZWRcbiAgICogQHBhcmFtIHBhdGggQ29uc2lkZXIgb25seSBjb21taXRzIHRoYXQgYXJlIGVub3VnaCB0byBleHBsYWluIGhvdyB0aGUgZmlsZXMgdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHBhdGhzIGNhbWUgdG8gYmUuXG4gICAqIFRoaXMgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpciBvZiB0aGUgYGJ1bXBgIHRhc2ssIGkuZS4gdG8gb25seSBjb25zaWRlciBjb21taXRzIG9mIGEgc3VicHJvamVjdCB1c2UgYFwiLlwiYC5cbiAgICovXG4gIHN0YXRpYyBvZlR5cGUodHlwZXM6IHN0cmluZ1tdLCBwYXRoPzogc3RyaW5nKSB7XG4gICAgY29uc3QgYWxsb3dlZFR5cGVzID0gdHlwZXMuam9pbihcInxcIik7XG5cbiAgICAvLyBAc2VlOiBodHRwczovL2dpdGh1Yi5jb20vY29udmVudGlvbmFsLWNvbW1pdHMvcGFyc2VyL2Jsb2IvZWVlZmI5NjFlYmY1YjlkZmVhMGZlYThiMDZmOGFkMzRhMWU0MzliOS9saWIvcGFyc2VyLmpzXG4gICAgLy8gLUUgcmVxdWlyZXMgdGhpcyB0byBiZSBQT1NJWCBFeHRlbmRlZCBSZWd1bGFyIEV4cHJlc3Npb24sIHdoaWNoIGNvbWVzIHdpdGggY2VydGFpbiBsaW1pdGF0aW9uc1xuICAgIC8vIHNlZSBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9SZWd1bGFyX0V4cHJlc3Npb25zL1BPU0lYLUV4dGVuZGVkX1JlZ3VsYXJfRXhwcmVzc2lvbnMgZm9yIGRldGFpbHNcbiAgICBjb25zdCBjbWQgPSBgZ2l0IGxvZyAtLW5vLW1lcmdlcyAtLW9uZWxpbmUgJExBVEVTVF9UQUcuLkhFQUQgLUUgLS1ncmVwIFwiXigke2FsbG93ZWRUeXBlc30pezF9KFxcXFwoW14oKVs6c3BhY2U6XV0rXFxcXCkpPyghKT86W1s6Ymxhbms6XV0rLitcImA7XG5cbiAgICByZXR1cm4gbmV3IFJlbGVhc2FibGVDb21taXRzKHdpdGhQYXRoKGNtZCwgcGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2Ugb25seSBmZWF0dXJlcyBhbmQgZml4ZXNcbiAgICpcbiAgICogU2hvcnRoYW5kIGZvciBgUmVsZWFzYWJsZUNvbW1pdHMub25seU9mVHlwZShbJ2ZlYXQnLCAnZml4J10pYC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggQ29uc2lkZXIgb25seSBjb21taXRzIHRoYXQgYXJlIGVub3VnaCB0byBleHBsYWluIGhvdyB0aGUgZmlsZXMgdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHBhdGhzIGNhbWUgdG8gYmUuXG4gICAqIFRoaXMgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpciBvZiB0aGUgYGJ1bXBgIHRhc2ssIGkuZS4gdG8gb25seSBjb25zaWRlciBjb21taXRzIG9mIGEgc3VicHJvamVjdCB1c2UgYFwiLlwiYC5cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlc0FuZEZpeGVzKHBhdGg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gUmVsZWFzYWJsZUNvbW1pdHMub2ZUeXBlKFtcImZlYXRcIiwgXCJmaXhcIl0sIHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBhbiBhcmJpdHJhcnkgc2hlbGwgY29tbWFuZCB0byBmaW5kIHJlbGVhc2FibGUgY29tbWl0cyBzaW5jZSB0aGUgbGF0ZXN0IHRhZy5cbiAgICpcbiAgICogQSBuZXcgcmVsZWFzZSB3aWxsIGJlIGluaXRpYXRlZCwgaWYgdGhlIG51bWJlciBvZiByZXR1cm5lZCBjb21taXRzIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICAgKiBNdXN0IHJldHVybiBhIG5ld2xpbmUgc2VwYXJhdGUgbGlzdCBvZiBjb21taXRzIHRoYXQgc2hvdWxkIGNvbnNpZGVyZWQgcmVsZWFzYWJsZS5cbiAgICogYCRMQVRFU1RfVEFHYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGFjdHVhbCBsYXRlc3QgdGFnIGZvciB0aGUgZ2l2ZW4gcHJlZml4LipcbiAgICpcbiAgICogQGV4YW1wbGUgXCJnaXQgbG9nIC0tb25lbGluZSAkTEFURVNUX1RBRy4uSEVBRCAtLSAuXCJcbiAgICovXG4gIHN0YXRpYyBleGVjKGNtZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBSZWxlYXNhYmxlQ29tbWl0cyhjbWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihwdWJsaWMgY21kOiBzdHJpbmcpIHt9XG59XG5cbi8qKlxuICogQXBwZW5kIGEgcGF0aCBhcmd1bWVudCB0byBhIGdpdCBjb21tYW5kIGlmIG9uZSBpcyBwcm92aWRlZFxuICovXG5mdW5jdGlvbiB3aXRoUGF0aChjbWQ6IHN0cmluZywgcGF0aD86IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYCR7Y21kfSAtLSAke3BhdGh9YDtcbiAgfVxuXG4gIHJldHVybiBjbWQ7XG59XG4iXX0=